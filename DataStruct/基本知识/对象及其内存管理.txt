第二章	对象及其内存管理
总结:
	1)本章主要介绍Java面向对象中比较容易混淆的部分
	2)并没有介绍面向对象中那些基本语法知识
	3)而主要从内存运行角度来分析面向对象中的类、对象细节
	4)包括Java对类变量、实例变量的初始化细节
	5)内存中子类实例的实例变量存储，以及程序如何访问它们
	6)基类、派生类的类变量存储，以及程序如何访问它们
	7)由于派生类实例在内存中存储的复杂性，而且调用派生类构造器时，
		基类构造器总会调用一次，因此应该尽量避免在基类的构造器中
		访问子类的实例变量，调用子类重写方法
	8)本章最后深入分析了final修饰符的功能，具体讲解了哪些final变量
		相当于"宏变量"，匿名内部类中使用局部变量必须使用final修饰

1.实例变量和类变量
	1)形参：
		(1)在方法签名中定义的局部变量，由方法调用者为其赋值，
			随方法结束而消亡
	2)方法内的局部变量:
		(2)在方法内定义的局部变量，必须在方法内对其进行显示初始化
			这种类型的局部变量从初始化完成后开始生效
			随方法结束而消亡
	3)代码块内的局部变量，
		(3)在代码块内定义的局部变量，必须在代码块内对其进行显示初始化
			这种类型的局部变量从初始化完成后开始生效
			随代码块的结束而消亡
	4)局部变量的作用时间很短暂，它们都被存储在栈内存中
	5)static
		(1)成员变量没有使用时
			非静态变量或实例变量
		(2)成员变量使用时
			静态变量或类变量
2.实例变量和类变量的属性
	1)使用static修饰的成员变量是类变量，属于该类本身
	2)没有使用static修饰的成员变量是实例变量，属于该类的实例
	3)在同一个jvm内，每个类只对应一个Class对象，但每个类可以创建多个对象
	4)由于同一个jvm内每个类只对应一个Class对象，因此同一个jvm内的一个类的类变量(static)
		只需一块内存空间，但对于实例变量而言，该类每创建一次实例
		就需要为实例变量分配一块内存空间。
		也就是有几个实例，实例变量就需要几块内存空间
3.实例变量的初始化时机
	1)对于实例变量而言，它属于Java对象本身。
		从程序运行的角度来看，每次创建Java对象都需要为实例变量分配内存空间
		并对实例变量执行初始化
	2)从语法角度来看，程序可以在三个地方对实例变量执行初始化
		(1)定义实例变量时指定初始值
		(2)非静态代码块中对实例变量指定初始值
		(3)构造器中对实例变量指定初始值
		其中第1、2两种方式比第3种更早执行
		1、2执行顺序取决于排列顺序
		参见InitTest	非静态代码块和初始化赋值按顺序执行
4.类变量的初始化时机
	1)类变量属于Java类本身，从程序运行的角度来看，每个jvm对一个Java类
		只初始化一次，因此只有每次运行Java程序时，才会初始化该Java类
		才会为该类的类变量分配内存空间，并执行初始化
	2)从语法角度来看，程序可以在两个地方对类变量执行初始化
		(1)定义类变量时指定初始值
		(2)静态初始化块中对类变量指定初始值
		1、2执行顺序取决于排列顺序
		参见StaticInitTest和PriceTest
5.父类构造器
	1)当创建任何Java对象时，程序总会先依次调用每个父类的非静态初始化代码块、构造器(总是从Object开始)
		执行初始化，然后才调用本类的非静态代码块，构造器执行初始化
	2)当所有的父类非静态初始化块、构造器依次调用完成后
		系统调用本类的非静态初始化块、构造器执行初始化，最后返回本类的实例
		参见InitTestEx
	3)super调用用于显式调用父类构造器，this调用用于显式调用本类中另一个重载的构造器
		super调用和this调用都只能在构造器中使用，而且super调用和this调用都必须作为
		构造器的第一行代码，因此构造器中的super调用和this调用最多只能使用其中之一
		而且最多只能调用一次
	 4)编译时，this指代当前类，运行时，指代当前运行调用的对象
	5)如果父类构造器调用了被子类重写的方法，且通过子类构造器来创建子类对象，调用(不管显式还是隐式)
		了这父类的构造器，就会导致子类的重写方法在子类构造器的所有代码之前被执行，从而导致
		出现子类的重写方法访问不到子类的实例变量值的情形
6.调用被子类重写的方法
	1)在访问权限允许的情况下，派生类可以调用基类方法
		这是因为派生类继承基类会获得基类定义的成员变量和方法
		但基类不能调用派生类方法，因为基类根本无从知道它将被哪个派生类继承
		它的派生类将会增加怎样的方法
	2)但有一种特殊情况，当派生类方法重写了基类方法之后
		基类表面上只是调用属于自己的方法，但由于该方法被派生类重写
		随着调用上下文的改变，将会出现基类调用派生类方法的情形
		参见Wolf
7.父子实例的内存控制
	1)继承成员变量和继承方法的区别
		由javaP工具可以看出编译器在处理方法和成员变量时存在的区别
		对于基类中定义的Public成员变量name而言
		系统依然将其保留在基类当中
		并不会将它转移到其派生类中
		这使得基类和派生类可以同时拥有同名的实例变量
	2)如果派生类重写了基类方法
		意味着派生类里定义的方法彻底覆盖了父类的同名方法
		系统将不可能将基类里的方法转移到子类中
		对于实例变量则不存在这样的情况
		即使派生类中定义了于基类完全同名的实例变量，这个实例变量也依然
		不可能覆盖父类中定义的实例变量
	3)因为继承成员变量和继承方法之间存在这样的差别
		所有对于一个引用类型的变量而言，
		当通过该变量访问它所引用的对象的实例变量时，
		该实例变量的值取决于声明该(变量)时的类型
		当通过该变量来调用它所引用的对象的方法时
		该方法行为取决于它所实际引用的(对象)的类型
8.内存中的子类实例
	1)参见Sub
	2)系统内存中并不存在一级基类和二级基类两个对象，程序内存中只有
		一个派生类对象，只是这个派生类对象中不仅保存了在派生类类中定义的
		所有实例变量，还保存了它的
		所有基类所定义的全部实例变量
	3)super
		(1)参见Apple
			从中可以看出，通过Apple对象的getSupper方法所返回的依然是Apple对象本身
			只是它的声明类型是Fruit，因此通过f变量访问color实例变量时
			该实例变量的值由Fruit类决定，但通过f变量调用info方法时，该方法的行为由f变量实际所引用
			Java对象决定，因此程序输出Apple方法
		(2)通过上面分析可以看出，super关键字本身并没有引用任何对象，它甚至
			不能被当成一个真正的引用变量来使用，主要有以下两个原因
				a.子类方法不能直接使用return super
					但使用retrun this返回调用该方法的对象是允许的
				b.程序不允许直接把super当成变量使用，例如，试图判断super和a变量
					是否引用同一个Java对象
					super==a，这条语句将引起编译错误
9.结论
	1)至此，对基、派生类对象在内存中的存储有了准确的结论，
		当程序创建一个派生类对象时，系统不仅会为该类中定义的实例变量分配内存
		也会为其父类中定义的所有实例变量分配内存，
		即使子类定义了与父类同名的实例变量
		也就是说
		当系统创建一个Java对象时，如果该Java类有两个基类
		(直接基类A和间接基类B)
		假设A类中定义了2个实例变量
		B类中定义了3个实例变量，
		当前类中定义了2个实例变量
		那么这个Java对象将会保存2+3+2=7个实例变量
	2)如果在子类里定义了与基类中已有变量同名的变量，那么派生类
		中定义的变量会隐藏基类中定义的变量
		注意，不是完全覆盖
		因此系统在创建子类对象时，依然会为父类中
		定义的、被隐藏的变量分配内存空间
	3)为了在派生类方法中访问基类中定义的、被隐藏的实例变量
		或者为了在子类方法中调用基类中定义的、被覆盖的方法
		可以使用super作为限定来修饰这些实例变量和实例方法
	4)因为派生类中定义与基类中同名的实例变量并不会完全覆盖父类中定义的实例变量，
		它只是简单地隐藏了父类中的实例变量，所以会出现特殊的情形
		参见HideTest
10.基类、派生类的类变量
	1)与实例变量不同，类变量属于类本身
		而实例变量则属于Java对象
	2)类变量在类初始化阶段完成初始化，
		而实例变量则在对象初始化阶段完成初始化
	3)由于类变量本质上属于类本身，因此通常不会涉及实例变量那样复杂的情形，
		但由于Java允许通过对象来访问类变量，因此也可以使用super作为限定
		来访问基类中定义的类变量
		参见StaticSub
11.final修饰符
	1)被final修饰的实例变量必须显式指定初始值，
		而且只能在如下三个位置指定初始值
		(1)定义final实例变量时指定初始值
		(2)在非静态初始化块中为final实例变量指定初始值
		(3)在构造器中为final实例变量指定初始值
	2)对于final类变量而言，同样必须显式地指定初始值，而且final类变量只能在两个地方指定初始值
		(1)定义final类变量时指定初始值
		(2)在静态初始化块中为final类变量指定初始值
	3)final的功能
		(1)被final修饰的变量一旦被赋初始值，final变量的值以后将不会被改变
		(2)对于一个使用final修饰的变量而言，如果定义该final变量时就指定初始值
			而且这个初始值可以在编译时就确定下来
			那么这个final变量将不再是一个变量，系统会将其当成
			"宏变量"处理，也就是说
			所有出现该变量的地方，系统将直接把他当成对应的值处理
		(3)final方法不能被重写
			a.有些情况需要指出，如果基类中某个方法使用了final修饰符进行修饰
				那么这个方法将不可能被它的派生类访问到，因此这个方法也
				不可能被它的子类重写
				从这个意义上来说，
				private和final同时修饰某个方法没有太大意义，但允许这么做
	4)内部类中的局部变量
		(1)如果程序需要在匿名内部类中使用局部变量
			那么这个局部变量必须使用final修饰符修饰
		(2)Java要求所有被内部类访问的局部变量都使用final修饰也是有其原因的
			对于普通的局部变量而言，它的作用域就停留在该方法内
			当方法执行结束后，该局部变量也随之消失
			但内部类则可能产生隐式的闭包，
			闭包将使得局部变量脱离它所在的方法继续存在
		