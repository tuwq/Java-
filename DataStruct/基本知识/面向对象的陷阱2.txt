第七章 面向对象的陷阱 下
1.方法重写的陷阱
	1)重写private方法
		(1)对于使用private修饰符修饰的方法，只能在当前类中访问该方法
		(2)派生类无法访问基类的private方法，当然也就无法重写该方法
	2)如果派生类中定义了一个与基类的private方法具有相同的方法名，相同的形参列表、相同的返回值类型的方法
		依然不是重写，只是派生类中重新定义了一个新方法
2.重写其他访问权限的方法
	1)上一小节介绍了基类中定义的private方法不可能被派生类重写，其关键原因就是派生类不可能访问基类的private方法
	2)还有一种情况，父类定义了使用默认访问控制符(也就是不使用访问控制符缺省)修饰的方法，这个方法同样可能无法被重写
	3)对于不使用访问控制符修饰的方法，它只能被与当前类处于同一个包中的其他类访问，其他包中的派生类依然无法访问该方法
	4)程序在基类里定义了一个run()方法，该方法不使用任何访问控制符修饰，表面它是包访问控制权限
	5)这意味着，只有与当前类处于同一个包中的其他类才能访问该方法
3.非静态内部类的陷阱
	1)非静态内部类的构造器
		(1)非静态内部类Inner并没有无参数的构造器，它的构造器需要一个Outer参数
		(2)这符合非静态内部类的规则：
			非静态内部类不可能有无参数的构造器，即使系统为非静态内部类提供一个默认构造器
			这个默认的构造器也需要一个外部类形参
		(3)程序表面上调用Inner无参数的构造器创建实例，实际上
			虚拟机底层会将this(代表当前默认的Outer对象)作为实参传入Inner构造器
			程序通过反射指定调用Inner类无参数的构造器，引发了运行时异常
		(4)如果程序员为非静态内部类定义一个无参数的构造器，编译器将为之生成对应的需要外部类参数的构造器
			程序员为它定义一个带String参数的构造器，编译器将为之生成对应的构造器增加了一个Outer参数
		(5)由此可见，系统在编译阶段总会为非静态内部类的构造器增加一个参数，
			非静态内部类的构造器的第一个形参类型总是外部类
	2)非静态内部类不能拥有静态成员
		(1)对于非静态内部类而言，由于它本身就是一个非静态的上下文环境，因此非静态内部类不允许拥有静态成员
	3)非静态内部类的子类
		(1)由于非静态内部类没有无参数的构造器，因此通过非静态内部类派生派生类时也可能存在一些陷阱
		(2)参见OutTest
		(3)由于非静态内部类In必须寄生在Out对象之内，因此基类Out.In，根本没有无参数的构造器
			而程序定义其派生类Out.In时，也没有定义构造器，那么系统会为它提供一个无参数的构造器
			在OutTest无参数的构造器内，编译器会增加代码super()--派生类总会调用基类的构造器
			对于这个super()调用，指定调用父类Out.In无参数的构造器必然会导致编译错误(Out.In始终有一个外部类参数)
			为了解决这个问题，应该为outTest显示定义一个构造器，在该构造器中显式调用Out.In基类对应的构造器
			也就是形式 new Out().super()
		(4)总之，由于非静态内部类必须寄生在外部类的实例之中，程序创建非静态内部类对象的实例，
			派生非静态内部类的派生类时都必须特别小心，否则很容易引入陷阱
		(5)如果条件允许，推荐多使用静态内部类，而不是非静态内部类
			对于静态内部类来说，外部类相当于它的一个包，因此静态内部类的用法就简单多了，限制也少多了
4.static关键字
	1)static是一个常见的修饰符，它只能用于修饰在类里定义的成员:Field、方法、内部类、初始化块、内部枚举类
		static的作用就是把类里定义的成员变成静态成员，也就是所谓的类成员
	2)静态方法属于类
		(1)被static关键字修饰的成员(Field、方法、内部类、初始化块、内部枚举类)属于类本身，
			而不是单个的Java对象，具体到静态方法也是如此，静态方法属于类，而不是属于Java对象
	3)静态内部类的限制
		(1)前面介绍内部类时已经指出，当程序需要使用内部类时，应尽量考虑使用静态内部类，而不是非静态内部类
			当程序使用静态内部类时，外部类相当于静态内部类的一个包，因此使用起来比较方便，
			但另一方面，这也给静态内部类增加了一个限制-静态内部类不能访问外部类的非静态成员
5.native方法的陷阱
	1)在Java方法定义中一类特殊的方法，native方法。
	2)对于native方法而言，Java程序不会为该方法提供实现体
	3)native方法就是一个"抽象方法"，只有方法签名，没有方法体，这就是native方法
	4)native方法通常需要借助C语言来完成，即需要使用C语言为Java方法提供实现，其实现步骤如下
		(1)用javah编译第一步生成的class文件，将产生一个.h文件
		(2)写一个.cpp文件实现native方法，其中需要包含第一步产生的.h文件(.h文件中又包含了JDK带的jni.h文件)
		(3)将第2步的.cpp文件编译成动态链接库文件
		(4)在Java中用System的loadLibrary()方法或Runtime的loadLibrary()方法加载第3步产生的动态链接库文件
			就可以在Java程序中调用这个native方法了
		(5)这里就产生了一个问题:在第3步编译.cpp文件时，将会使得该程序依赖于当前的编译平台。
			也就是说，native方法做不到平台，它在不同平台上可能表现出不同的行为，比如线程停顿地实际时间值
		(6)千万不要过度相信JDK所提供的方法，虽然Java语言本身是跨平台的，但Java的native方法还是要依赖于具体的平台
			尤其是JDK所提供的方法，更是包含了大量的native方法，使用这些方法时，要注意它们在不同平台上可能存在的差异
		