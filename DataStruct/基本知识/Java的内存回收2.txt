第四章 Java的内存回收 下
1.堆内存的分代回收
	1)分代回收的一个依据就是对象生存时间的长短，然后根据不同代采取不同不同的垃圾回收策略
	2)采用这种"分代回收"的策略基于如下两点事实
		(1)绝大对数的对象不会被长时间引用，这些对象在其Young期间就会被回收
		(2)很老的对象(生存时间很长)和很新的对象(生存时间很短)之间很少存在相互作用的情况
		(3)上面两点事实不仅在Java语言中如此，其他面向对象的编程语言也大致遵循这两个事实
	3)对于Young代的对象而言，大部分对象都会很快就进入不可达状态，只有少量的对象能熬到垃圾回收执行时
		(1)垃圾回收器只需要保留Young代中处于可达状态的对象
		(2)如此一来，采用复制算法只需要少量复制成本，因此大部分垃圾回收器对Young代都采用复制算法
	4)Young代
		(1)对Young代采用复制算法只需要遍历那些处于可达状态的对象，而且这些对象的数量较少，可复制成本也不大
		(2)Young代由一个Eden区和两个Survivor区构成，绝大多数对象先分配到Eden区中(有一些大对象可能会直接被分配到Old代)
		(3)Survivor区中的对象都至少在Young代中经历过一次垃圾回收
		(4)所以这些对象在被转移到Old代之前会先保留在Survivor空间
		(5)同一时间两个Survivor空间中有一个用来保存对象，而另一个是空的，用来保存垃圾回收时保存Young代中的对象
		(6)每次复制就是将Eden和第一个Survivor区的可达对象复制到第二个Survivor区
		(7)然后清空Eden与第一个Survivor区
		(8)Eden和Survivor区的比例通过-XX:SurvivorRatio附加选项来设置，默认为32
		(9)如果Survivor区太大则会产生浪费，太小则会使一些Young代的对象提前进入Old代
	5)Old代
		(1)如果Young代中的对象经过数次垃圾回收依然没有被回收掉，即这个对象经过足够长的时间还处于可达状态
		(2)垃圾回收机制就会将这个对象转移到Old代
		(3)Old代的大部分对象都是"久经考验"的"老人"了，因此它们没那么容易死
		(4)随着时间的流逝，Old代的对象越来越多，所以Old代的空间要比Young代的空间更大
		(5)old代的垃圾回收具有如下两个特征
			a.Old代垃圾回收的执行频率无须太高，因为很少有对象会死掉
			b.每次对Old代执行垃圾回收都需要更长的时间来完成
		(6)基于以上考虑，垃圾回收器通常会使用标记压缩算法，避免复制Old代大量对象，
			由于Old代对象不会很快死亡，也不会产生大量内存碎片
	6)Permanent代
		(1)Permanent代主要用于装载Class、方法等信息，默认为64MB
		(2)垃圾回收机制通常不会回收Permanent代中的对象
		(3)对于那些需要加载很多类的服务器程序，往往需要加大Permanent代的内存，否则可能会因为内存不足而导致程序终止
	7)当Young代的内存将要用完时，垃圾回收机制会对Young代进行垃圾回收，垃圾回收机制会采用较高的频率对Young进行扫描，被称为次要回收
	8)当Old代的内存将要用完时，垃圾回收机制会进行全回收，Young和Old都进行回收，被称为主要回收
2.常见的垃圾回收器
	1)串行回收器
		(1)串行回收器通过运行Java程序时使用-XX:+UseSerialGC附加选项启用
		(2)串行回收器对Young代和Old代的回收的都是串行的(只是用一个CPU)
		(3)而且垃圾回收期间会使得应用程序产生暂停
		(4)Young代采用串行复制算法，Old代采用串行标记压缩算法
	2)并行回收器
		(1)并行回收器通过运行Java程序时使用-XX:+UseParallelGC附加选项启用
		(2)并行回收器对于Young代采用与串行回收器基本相似的回收算法，只是增加了多CPU并行的能力
		(3)线程数默认为CPU个数，当计算机中的CPU很多时，可以用-XX:ParallelGCThreads=size来减少并行线程的数目
		(4)并行回收器对于Old代采用与串行回收器完全相同的回收算法，不管有计算机有几个CPU，依然采用单线程、标记整理回收
	3)并行压缩回收器
		(1)并行压缩回收器通过运行Java程序时使用-XX:+UserParallelOldGC附加选项启用，一样可设置并行线程数量
		(2)它与并行回收最大不同是对Old代的回收使用了不同的算法
		(3)最终会取代并行回收器
		(4)主要改变体现在Old代的回收上
			a.系统首先将Old代划分成几个固定大小的区域，在mark阶段，多个垃圾回收线程会并行标记Old代中的可达对象
				当某个对象被标记成可达对象时，还会更新该对象所在区域的大小，以及该对象的位置信息
			b.接下来是summary阶段,summary阶段直接操作Old代的区域，而不是单个对象
				由于每次垃圾回收的压缩都会在Old代的左边部分存储大量的可达对象，对这样高密度的可达对象区域进行压缩往往很不划算
				所以summary阶段从最左边的区域开始检测每个区域的密度，
				当检测到某个区域能回收的空间达到某个数值时(也就是可达对象的密度较小时)
				垃圾回收器会判定该区域，以及该区域的右边的所有区域都应该进行回收
				而该区域的左边的区域都会被标识为密集区域
				垃圾回收器既不会把新对象移动到这些密集区域，也不会对该密集区域进行压缩
				该区域和其右边的所有区域都会被压缩并回收空间
				summary阶段目前还是串行操作，虽然并行是可以实现的，但重要性不如对mark和压缩阶段的并行重要
			c.最后是compact阶段，回收器利用summary阶段生成的数据识别出有哪些区域是需要装填的，
				多个垃圾回收线程可以并行地将数据复制到这些区域中，经过这个过程后，
				Old代的一端会密集地存在大量的活动对象，另一端则存在大块的空闲块
	4)并发标识-清理回收器(CMS)
		(1)并发标识-清理回收器通过运行Java程序时使用-XX:+UseConcMarkSweepGC附加选项启用
		(2)CMS回收器对Young代的回收方式和并行回收器的回收方式完全相同
		(3)由于对Young代的回收依然采用复制回收算法，因此垃圾回收时依然会导致程序暂停，除非依靠多CPU并行来提高垃圾回收速度
		(4)CMS对Old代的回收多数是并发操作，而不是并行操作。
			a.垃圾回收开始时需要一个短暂的暂停，此阶段称为初始阶段(mark)，这个阶段仅仅表示出那些被直接引用的对象
			b.接下来进入并发标识阶段，垃圾回收器会依据在初始标识中发现的可达对象来寻找其他的可达对象
			c.由于在并发标识阶段应用程序也会同时运行，无法保证所有的可达对象都被标识出来
				因此应用程序会再次很短地暂停一下，多线程并行地重新标识之前可能因为并发而漏掉的对象
				这个阶段被成为再标识阶段
		(5)CMS回收器的最大改进在于对Old代的回收，它只需两次短暂的暂停，
			而其他过程都是与应用程序并发执行的，因此对实时性要求较高的程序更合适
		(6)对于串行、标记压缩回收器而言，它可以等到Old代满了之后再开始回收，反正垃圾回收器总会让应用程序暂停
		(7)但CMS回收器要与应用程序并发运行，如果Old代满了才开始回收，那么应用程序将无内存可用，
			所以系统默认在Old代68%满的时候就开始回收
		(8)CMS不会进行内存压缩，也就是，不可达对象占用的内存被回收以后，垃圾回收器不会移动可达对象占用的内存
		(9)由于Old代的可用空间不是连续的，因此CMS垃圾回收器必须保存一份可用空间的列表
			当需要分配对象时，垃圾回收器就要通过这份列表找到容纳新对象的空间
			这样就会使得分配内存时的效率下降，从而影响了Young代回收过程中将Young代对象移动到Old代的效率
		(10)对于CMS回收器而言，当垃圾回收器执行并发标识时，应用程序在运行的同时也在分配对象，
			因此Old代也同时在增长，而且，虽然可达对象在标识阶段会被标识阶段会被识别出来
			但有些在标识阶段成为垃圾的对象并不能立即被回收，只有等下次垃圾回收时才能被回收，
			因此CMS回收器较之前面的几种回收器需要更大的堆内存
		(11)对于Permanent代内存，CMS可通过运行Java程序时使用-XX:CMSClassUnloading-Enabled附加选项来强制回收Permanent代内存
3.内存管理小技巧
	1)尽量使用直接量
		(1)String str="Hello"
		此时创建一个hello字符串，而且jvm的字符串缓存池还会缓存这个字符串
		(2)String str=new String("Hello")
		此时程序同样创建了一个缓存在字符串缓存池中的Hello字符串
		除此之外，str所引用的String对象底层还包含了一个char[]数组，这个数组依次存放了H、e、l、l、o
	2)使用StringBuilder和StirngBuffer进行字符串连接
		(1)String、StringBuilder、StirngBuffer都可代表字符串
		(2)String代表字符序列不可变的字符串，而StringBuilder、StirngBuffer都代表字符序列可变的字符串
		如果程序使用多个String对象进行字符串连接运算，在运行时将生成大量的临时字符串
		这些字符串会保存在内存中从而导致程序性能下降
	3)尽早释放无用对象的引用
		(1)大部分时候，方法的局部引用变量所引用的对象会随着方法的结束而变成垃圾
		(2)因为局部变量的生存期限更短，当方法运行结束时，该方法内的局部变量就结束了生存期限
		(3)大部分时候程序无须将局部引用变量显式设为null
		(4)但当方法结束前还需要执行耗时、耗内存操作或调用耗时、耗内存方法时，那么显式设为null就很有必要
	4)尽量少用静态变量
		(1)从理论上来说，Java对象何时被回收由垃圾回收机制决定，对程序员来说是不确定的
		(2)垃圾回收机制判断一个对象是否是垃圾的唯一标准就是该对象是否有引用变量引用它，因此推荐尽早释放对象的引用
		(3)最坏情况是，某个对象被static变量所引用，那么垃圾回收机制通常是不会回收这个对象所占的内存的
		(4)static Object obj=new Object 只要obj变量还引用它，它就不会被垃圾回收机制所回收
	5)避免在经常调用的方法，循环中创建Java对象
		(1)在循环中会重复创建对象，且这些对象的生存时间并不长，接下来系统又需要回收它们所占的内存空间，使得程序的性能受到巨大影响
	6)缓存经常使用的对象
		(1)有些对象需要被经常调用，则可以考虑把这些对象用缓存池保存起来
		(2)这样当下次需要时就可直接拿出这些对象来用，典型的缓存就是数据连接池和redis
		(3)如果直接使用HashMap进行缓存，程序员需要手动控制HashMap容器里的key-value对不至于太多，因为太多会占用过大的内存
	7)尽量不要使用finalize方法
		(1)前面介绍垃圾回收机制时已经提到，在一个对象失去引用之后，垃圾回收器准备回收该对象之前
		(2)垃圾回来机制会先调用该对象的finalize()方法来执行资源清理，基于这种考虑，可能有些开发者会考虑使用finalize()方法来进行资源清理
		(3)实际上，将资源清理放在finalize()方法中完成是非常拙劣的的选择，根据前面介绍的垃圾回收算法，垃圾回收机制的工作量已经够大了
			尤其是回收Young代内存时，大都会引起应用程序暂停，使得用户难以忍受
		(4)在垃圾回收器本身已经严重制约应用程序性能的情况下，如果在选择使用finalize()方法进行资源清理，无疑是一种火上浇油的行为，
			这将导致垃圾回收器的负担更大，导致程序运行效率更差
	8)考虑使用SoftReference
		(1)当程序需要创建长度很大的数组时，可以考虑使用SoftReference来包装数组元素，而不是直接让数组元素来引用对象
		(2)SoftReference是一个很好的选择:当内存足够时，它的功能等同于普通引用，当内存不够时，它会牺牲自己，释放软引用所引用的对象
		(3)使用软引用引用对象时不要忘记软引用的不确定性，因此应用程序取出SoftReference所引用的Java对象之后，
			应该显式判断该对象是否为null，当该对象为null，应重建该对象