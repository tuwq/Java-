第十章 栈和队列
总结:
	1)本章主要介绍了两种常用的线性表:栈和队列，其中，栈代表只能在一端进行插入，删除操作的线性表，具有先进后出的特征
	2)队列代表一端只能进行插入，另一端只能进行删除的线性表，具有先进先出的特征
	3)本章还介绍了栈的基本概念和操作，其中重点介绍了栈的顺序存储和链式存储，以及队列的基本概念和操作
	4)重点介绍了队列的顺序存储和链式存储
1.栈
	1)栈的英文单词是Stack，它代表一种特殊的线性表，这种线性表只能在固定一端(通常认为是线性表的尾端)进行插入、删除操作
	2)栈的基本定义
		(1)栈是一种数据结构，它代表只能在某一段进行插入、删除操作的特殊线性表，通常就是在线性表的尾端进行插入、删除操作
		(2)对于栈而言，允许进行插入、删除操作的一端被称为栈顶，另一端则被称为栈底
		(3)如果一个栈不包含任何元素，那么这个栈就被称为空栈
		(4)从栈顶插入一个元素被称为进栈，将一个元素插入栈顶被称为"压入栈"，对应的英文说法为push
		(5)从栈顶删除一个元素被称为出栈，将一个元素从栈顶删除被称为"弹出栈"，对应的英文说法为pop
		(6)对于元素为a0,a1,a2,..,an-1的栈，假设栈中元素按a0,a1,a2,..,an-1的次序进栈，那么a0为栈底元素，an-1为栈顶元素。
			出栈时第一个弹出的元素应为栈顶元素，也就是an-1，也就是说，栈中元素的修改是按后进先出的原则进行的
		(7)归纳起来，可以在对栈下一个定义，栈就是一种后进先出的线性表
	3)栈的常用操作
		(1)栈是一种被限制过的线性表，通常不应该提供线性表中的如下方法
			a.获取指定索引处的元素
			b.按值查找数据元素的位置
			c.向指定索引处插入数据元素
			d.删除指定索引处的数据元素
		(2)从上面这些方法可以看出，栈不应该提供从中间任意位置访问元素的方法，也就是说，只允许在栈顶插入、删除元素
		(3)栈的常用操作如下
			a.初始化:通常是一个构造器，用于创建一个空栈
			b.返回栈的长度:该方法用于返回栈中数据元素的个数
			c.入栈:向栈的栈顶插入一个数据元素，栈的长度+1
			d.出栈:从栈的栈顶删除一个数据元素，栈的长度-1，该方法通常返回被删除的元素
			e.访问栈顶元素:返回栈顶的数据元素，但不删除栈顶元素
			f.判断栈是否为空:该方法判断栈是否为空，如果栈为空则返回true，否则返回false
			g.清空栈，将栈清空
		(4)对于栈这种数据结构而言，上面三个用粗体字标出(入栈、出栈、返)的方法就是它作为栈的标志性方法。
		(5)类似于线性表既可采用顺序存储的方式来实现，也可使用链式结构来实现，栈同样即可采用顺序结构来存储栈内元素，也可采用链式结构结构来存储栈内元素
	4)栈的顺序存储结构及实现
		(1)顺序存储结构的栈简称为顺序栈，它利用一组地址连续的存储单元依次存放从栈底到栈顶的数据元素。
			栈底位置固定不变，它的栈顶元素可以直接通过顺序栈底层数组的数组元素arr[size-1]来访问，顺序栈中的数据元素的物理关系和逻辑关系是一致的，
			先进栈的元素位于栈底，栈底元素的存储位置相对也比较小
		(2)进栈
			a.对于顺序的进栈操作而言，只需将新的数据元素存入栈内，然后让记录栈内元素个数的变量+1，程序即可再次再次arr[size-1]重新访问新的栈底元素
			b.由于顺序栈底层通常会采用数组来保存数据元素，因此可能出现的情况是，当程序试图让一个数据元素进栈时，底层数组已满，
				那么就必须扩充底层数组的长度来容纳新进栈的数据元素
		(3)出栈
			a.对于顺序栈的出栈操作而言，需要将栈顶元素弹出栈，程序要做两件事情
				<1.让记录栈内元素个数的变量减1
				<2.释放数组对栈顶元素的引用
			b.对于删除操作来说，只要让记录栈内元素个数的size减少1，程序即可通过arr[size-1]访问到新的栈顶元素，
				但不要忘记释放原来栈顶元素的数组引用，否则会引起内存泄露
		(4)参见SequenceStack<T>实现
	5)栈的链式存储结构及实现
		(1)类似地，程序可以采用单链表来保存栈中的所有元素，这链式结构的栈也被称为链栈，
			对于栈而言，栈顶元素不断第改变，程序只要使用一个top引用来记录当前栈顶元素即可
		(2)top引用变量永远引用栈顶元素，再使用一个size变量记录当前栈中包含多少个元素即可
		(3)进栈，对于链栈的进栈操作，程序只需要做如下两件事情
			a.让top引用指向新添加的元素，新元素的next引用指向元阿里的栈顶元素
			b.让记录栈内元素个数的size变量加1
		(3)出栈，对于链栈的出栈操作，需要将栈顶元素弹出栈，程序需要做两件事情
			a.让top引用指向原栈顶元素的下一个元素，并释放原来的栈顶元素
			b.让记录栈内元素个数的size变量减一
		(4)下面程序实现了一个链栈
		(5)参见LinkStack<T>实现
	6)经过上面的介绍可以看出，为了实现栈这种数据结构，程序有两种实现选择，顺序栈和链栈
	7)由于栈不需要实现随机存、取功能，它只需从栈顶插入、删除元素，因此顺序结构所提供的
		高效存、取就没有太大的价值了，即使采用链式结构的实现，程序同样可以高效地栈、入栈
	8)对于链栈而言，栈内包含几个元素，底层链式结构就只需保存几个节点，每个节点需要额外添加一个next引用，
		这会引起部分空间的浪费，但对于顺序栈来说，程序开始就需要在底层为它开辟一块连续的内存(数组)，
		这种空间浪费更大，从空间利用率的角度来看，链栈的空间利用率比顺序栈的空间利用率要高一些
	9)栈也是一种常用的数据结构，因此Java集合框架也提供了栈来供开发者使用，对于Java集合而言，它并未专门提供了一个Stack接口
		再为该接口提供顺序栈、链栈两种实现
		(1)java.util.Stack:它就是一个最普通的顺序栈，底层基于数组实现，这个Stack类是线程安全的，在多线程环境下也可放心使用
		(2)java.util.LinkedList:第九章已介绍过，LinkedList是一个双向链表，除此之外，LinkedList还可作为栈使用，
			查看该类API可以发现，它同样提供了push()、pop()、peek()等方法，这表明LinkedList其实还可以当成栈来使用，
			LinkedList代表栈的链式实现，但它是线程不安全的，如果需要在多线程环境下使用，则应该使用Collections类的工具方法将其"改造"成线程安全的类
2.队列
	1)队列是另一种被限制过的线性表，它使用固定的一端来插入数据元素，另一端只用于删除元素，也就是说，队列中元素的移动方向总是固定的，就像排队购物一样
		先进入队伍的顾客先获得服务，队伍中的顾客总是被固定方向移动，只有当排在自己前面的所有顾客获得服务之后，当前顾客才会获得服务
	2)队列的基本定义
		(1)队列是一种特殊的线性表，它只允许在表的前端进行删除操作，只允许在表的后端进行插入操作，进行插入操作的端被成为队尾，进行删除操作的端称为队头
		(2)如果队列中不包含任何元素，该队列就被称为空队列
		(3)对于一个队列来说，每个元素总是从队列的rear端进入队列，然后等待该元素之前的所有元素出队之后，当前元素才能出队，因此，把队列简称为先进先出的线性表
			<- a1(front) a2 a3 .. an(rear) <-
	3)队列的常用操作
		(1)队列同样是一种被限制过的线性表，通常不应该提供线性表中的如下方法
			a.获取指定索引处的元素
			b.按值查找数据元素的位置
			c.向指定索引处插入数据元素
			d.删除指定索引处的数据元素
		(2)从上面这些方法可以看出，队列不应该提供从中间任意位置访问元素的方法，也就是说，队列只允许在队列的前端(front)删除元素，只允许在队列的后端(rear)插入元素
		(3)队列的常用操作如下
			a.初始化:通常是一个构造器，用于创建一个空队列
			b.返回队列的长度:该方法用于返回队列中数据元素的个数
			c.加入元素:向队列的rear端插入一个数据元素，队列的长度+1
			d.删除元素:对队列的front端删除一个数据元素，队列长度-1，该方法通常返回被删除的元素
			e.访问队列的前端元素:返回队列的front端的数据元素，但不删除元素
			f.判断队列是否为空，该方法判断队列是否为空，如果队列为空则返回true，否则返回false
			g.清空队列:将队列清空
		(4)对于队列这种数据结构，上面三个粗体字标出的方法(加入元素、删除元素、访问队列的前端元素)就是它作为队列的标志性方法
		(5)类似于线性表即可采用顺序存储的方式来实现，也可采用链式结构来实现，队列同样既可采用顺序结构来存储队列元素，也可采用链式结构来存储队列元素
	4)队列的顺序存储结构及实现
		(1)系统采用一组地址连续的存储单元依次存放队列从rear端到front端的所有数据元素，程序只需front和rear两个整形变量来记录队列front端的元素索引、rear端的元素索引
		(2)顺序存储结构的队列简称顺序队列
		(3)顺序队列的front总是保存着队列中即将出队列的元素的索引，顺序队列中的rear总是保存着下一个即将进入队列的元素的索引，队列中元素的个数为rear-front
		(4)对于顺序队列而言，队列底层将采用数组来保存队列元素，每个队列元素在数组中的位置是固定不变的，
			变的只是rear和front两个整形变量，但有元素进入队列时，rear变量+1,当有元素从队列中移除时，front变量的值+1
		(5)下面程序实现了一个简单的顺序队列
		(6)参见SequenceQueue<T>实现
		(7)对于上面的顺序队列的实现，数据元素在底层数组中的位置是固定的，改变的只是rear、front两个整型变量，这个队列可能出现rear、front在数组外的现象
		(8)此时rear等于该队列底层的数组容量capacity，如果此时试图向队列里添加元素，将会引起队列已满的异常，这其实是一种"假满"的现象
			此时该队列底层的数组依然有6个空位可存储的数据元素，但程序已经加不进去了
		(9)对于"假满"问题，程序有如下解决方法
			a.每次将元素移除队列时都将队列中所有元素向front端移动一位，这种方式下front值永远为0，有元素插入队列时rear值+1，有元素移出时rear值-1，
				但这种方式非常浪费时间，因为每次将元素从队列移除都需要进行"整体搬家"
			b.将数组存储区看成一个首尾相接的环形区域，当存放到数组的最大地址之后，rear值再次变为0，采用这种技巧存储的队列称为循环队列
	5)循环队列
		(1)为了重新利用顺序队列底层数组中已删除元素所占用的空间，消除可能出现的"假满"现象，可以将顺序队列改进为循环队列
		(2)循环队列是首尾相接的队列，当front、rear变量值达到底层数组的capacity-1之后，再前进一位就自动变成0，
		(3)对于循环队列，不管是队列是空还是满，都会出现一种情况:front==rear 
		(4)如果该底层数组中elementData[front]=null,则表明此时队列为空，否则表明该队列已满
		(5)参见LoopQueue<T>实现
		(6)上面程序创建了一个底层数组长度为3的队列，因此向队列中添加3个元素之后队列就处于"满的状态"，
			此时再向队列中添加元素将引发异常，当调用队列的remove()方法将front端的一个元素从队列移除后，多出来的空间将可以循环使用,可以再次添加新的数据元素
	6)队列的链式存储结构及实现
		(1)类似于使用链式结构保存线性表，也可以采用链式结构来存储队列的各元素，采用链式存储结构的队列也被称为链队列
		(2)对于链队列而言，由于程序需要从rear端添加元素，然后从front端移除元素，因此考虑对链队列增加front、rear两个引用变量，
			使它们分别指向链队列的头、尾两个节点
		(3)由于链队列采用链式结构来保存队列中的所有元素，该队列允许添加无限多个数据元素，因此链队列无队列满的问题
		(4)插入队列
			a.对于链队列而言，插入操作的实现非常简单，只要创建一个新节点，让原rear节点的next引用指向新的节点，再让rear引用指向该节点即可
		(5)移除队列
			a.对于链队列而言，移除操作的实现也非常简单，只要让front引用指向原front引用节点的下一个节点即可，当然，不要忘记释放原front节点的引用
		(6)参见LinkQueue<T>实现
	7)Java集合中的队列
		(1)Java的集合框架中提供了一个Queue接口，该接口代表了一个队列，实现该接口的类可以当成队列使用，Queue里包含了六个方法，用于代表队列所包含的3个标志性方法
			a.插入:在队列的rear端插入元素
			b.移除:在队列的front端删除元素
			c.访问队列的front端元素
		(2)Java为上面每个方法都提供了两个版本，具有特殊返回值的版本和抛出异常的版本，这样就产生了六个方法，关于Queue接口里定义的六个方法的说明
			a.插入 add(e):抛出异常版本		 offer(e):具有特殊返回值的版本
			b.移除 remove():抛出异常的版本    poll():具有特殊返回值的版本
			c.访问 element():抛出异常的版本  peek():具有特殊返回值的版本
		(3)Java提供了一个Queue接口，JDK1.5还为Queue接口提供了一个Deque接口，这个接口代表另一种特殊的队列-双端队列
	8)双端队列
		(1)双端队列代表一种特殊的队列，它可以在双端同时进行插入、删除操作
		(2)对于双端队列，由于它可以两端分别进入插入、删除操作
		(3)如果程序将所有的的插入、删除操作固定在一端进行，这个双端队列就变成前面介绍的栈
		(4)双端队列即可说是Queue的子接口，也可说是Stack(JDK并未提供这个接口)的子接口
		(5)因此，Deque即可当成队列使用，也可当成栈使用
		(6)由此可见，Deque其实就是Queue和Stack类混合而成的一种特殊的线性表，完全可以参考前面的Queue、Stack的实现来实现Deque
		(7)JDK为Deque提供了ArrayDeque、LinkedList两个常见的实现类，其中，ArrayDeque代表顺序存储结构的双端队列，LinkedList则代表链式存储结构的双端队列
	9)上一章还提到，LinkedList代表一种双向，链式存储结构的循环线性表，这里又提到LinkedList代表线程安全、链式结构的双端队列，
		因此可见，LinkedList实在是一个功能非常强大的集合类，事实上，LinkedList几乎是Java集合框架中方法最多的类
	10)JDK提供的工具类确实非常强大，它分别为线性表、队列、栈三种数据结构提供了两种实现，顺序结构和链式结构，虽然LinkedList工具类的功能非常强大，
		它既可当成线性表使用，也可当成栈使用，还可当成队列使用，但对大部分程序而言，使用ArrayList、ArrayDeque的性能比LinkedList更好
