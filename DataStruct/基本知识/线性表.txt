第九章 线性表
总结:
	1)本章主要介绍了线性表这种数据结构的相关知识，线性表是一种非常常用的数据结构
		几乎所有的实际编程中都需要使用线性结构来保存程序数据，
		Java干脆提供了ArrayList和LinkedList两种线性表实现类
	2)本章还详细介绍了线性表的基本概念和操作，包括线性表所能包含的操作
		顺序线性表的代码实现及其方法实现，链式线性表的代码实现及其方法实现
		单链表、循环链表和双向链表等，最后还分析了不同线性表实现的不同适用场景
1.数据结构定义
	1)编程的本质就是对数据(信息以数据的形式而存在)的处理，实际编程中不能不处理大量数据，
		因此实际动手编码之前必须先分析处理这些数据，处理数据之间存在的关系
	2)从数据的逻辑结构来分，数据元素之间存在的关联关系被称为数据的逻辑结构，归纳起来
		应用程序中的数据大致有如下四种基本的逻辑结构
			(1)集合:数据元素之间只有"同属于一个集合"的关系
			(2)线性结构:数据元素之间存在一个对一个的关系
			(3)树形结构:数据元素之间存在一个对多个的关系
			(4)图状结构或网状结构:数据元素之间存在多个对多个的关系
		对于数据不同的逻辑结构，在底层通常有两种物理存储结构
			(1)顺序存储结构
			(2)链式存储结构
	3)本书将重点介绍两种常用的逻辑数据结构:线性结构和树形结构，除此之外，本书将以Java语言来实现这些数据结构，
		并结合Java集合类来分析这些数据结构的功能
	4)线性表的定义及逻辑结构
		(1)对于常用的数据结构，可以将其简单地分为线性结构和非线性结构，其中线性结构主要是线性表，而非线性结构则主要是树和图
2.线性表详细实现
	1)线性表的定义及逻辑结构
		(1)线性表的定义及逻辑结构
			线性表是由n(n>=0)个数据元素(节点)a1,a2,a3,..,an组成的有限序列
			线性表中每个元素必须具有相同结构(即拥有相同的数据项)。线性表是线性结构中最常用而又最简单的一种数据结构，
			很多读者容易把线性表的数据元素理解成简单的数据值，其实不然，对于类似数据库表的数据而言，它本质上依然是线性表，
			只是它的每个数据元素都是一个"复合"的员工对象，每个数据元素包含多个数据项(也被称为Field):员工编号、姓名、年龄和学历
		(2)也就是说，线性表中每个数据元素其实可以包含若干个数据项，例如，使用ai来代表线性表中的第i个元素，其中ai元素可以包含若干个数据项
			关于线性表还可以有如下定义
			a.线性表中包含的数据元素个数n被称为表的长度，当线性表的长度为0时该表也被称为空表
			b.当n>0时，表可表示为(a1,a2,a3,..,an)
			c.总存在唯一的"第一个"数据元素
			d.总存在唯一的"最后一个"数据元素
			e.除第一个数据元素外，集合中的每一个数据元素都只有一个前驱的数据元素
			f.除最后一个数据元素外，集合中的每一个数据元素都只有一个后继的数据元素
	2)线性表的基本操作
		如果需要实现一个线性表，程序首先需要确定该线性表的每个数据元素，接下来，应该为该线性表实现如下基本操作
			(1)初始化:通常是一个构造器，用于创建一个空的线性表
			(2)返回线性表的长度:该方法用于返回线性表中数据元素的个数
			(3)获取指定索引处的元素:根据索引返回线性表中的数据元素
			(4)按值查找数据元素的位置:如果线性表中存在一个或多个与查找值相等的数据元素，那么该方法返回第一个搜索到的值相等的数据元素索引，否则返回-1
			(5)直接插入数据元素:向线性表的头部插入一个数据元素，线性表长度+1
			(6)向指定位置插入数据元素:向线性表的指定索引处插入一个数据元素，线性表长度+1
			(7)直接删除数据元素:删除线性表头部的数据元素，线性表长度-1
			(8)删除线性表中指定位置的数据元素:删除线性表中指定索引处的数据元素，线性表长度-1
			(9)判断线性表是否为空:该方法判断线性表是否为空，如果线性表为空，则返回true，否则返回false
			(10)清空线性表:将线性表清空
	3)顺序存储结构
		(1)线性表的顺序存储结构是指用一组地址连续的存储单元依次存放线性表	的元素。
			当程序采用顺序存储结构来实现线性表时，线性表中相邻元素的两个元素ai和ai+1对应的存储地址loc(ai)和loc(ai+1)也是相邻的
		(2)换句话来说，顺序结构线性表中数据元素的物理关系和逻辑关系是一致的，线性表中的数据元素的存储地址按如下公式计算
			loc(ai)=loc(a0)+i*b(0<i<n)
			a.上面公式中b代表每个数据元素的存储单元，从上面公式可以看出，程序获取线性表中每个元素的存储起始地址的时间相同，读取表中数据元素的时间也相同
				而且顺序表中每个元素都可随机存取，因此顺序存储的线性表是一种随机存储的的存储结构
		(3)为了使用顺序结构实现线性表，程序通常会采用数组来保存线性表中的数据元素
		(4)当使用数组来保存线性表中的元素时，程序可以很容易地实现线性表中所包含的方法，但当试图向线性表的指定位置添加元素时，系统实现该方法则稍微有些复杂
		(5)线性表的插入运算是指在表的第i(0<=i<n)个位置插入一个新的数据元素x,使长度为n的线性表，
			a0,..,ai-1,ai,..,an-1 变成长度为n+1的线性表
			a0,..,ai-1,x,ai,..,an-1
		(6)对于这个插入操作示意图，还有一个必须考虑的问题，由于顺序结构线性表底层采用数组来存储数据元素，因此插入数据元素时必须保证不会超出底层数组的容量
			如果线性表中元素的个数超出了底层数组的长度，那么就必须为该线性表扩充底层数组的长度
		(7)掌握上面的示意图之后，接下来就可以采用数组来实现顺序结构线性表了，下面程序是一个简单的顺序结构线性表的源代码
		(8)参见SequenceList<T>	
		(9)这个SequenceList<T>类部分实现了ArrayList的功能，或者说，它其实是一个简单版本的ArrayList
		(10)实际上，线性表的英文单词就是List，ArrayList就是JDK为线性表所提供的顺序实现
	4)链式存储结构
		(1)链式存储结构的线性表(简称为链表)将采用一组地址任意的存储单元存储方法线性表中的数据元素
		(2)链式存储结构的线性表不会按线性的逻辑顺序来保存数据元素，它需要在每一个数据元素里保存一个引用下一个数据元素的引用(或者叫指针)
		(3)由于不是必须按顺序存储，链表在插入、删除数据元素时比顺序线性表快得多，但是查找一个节点或者访问特定编号的节点则比顺序线性表慢很多
		(4)使用链表结构可以克服顺序线性表(基于数组)需要预先知道数据大小的缺点，链表结构可以充分利用计算机的内存空间，实现灵活的内存动态管理
			但链表结构失去了数组随机存取的优点，同时链表由于增加了节点的指针域，空间开销比较大
		(5)对于链式存储结构的线性表而言，它的每个节点都必须包含数据元素本身和一个或两个用来引用上一个/下一个节点的引用。有如下公式:
			节点=数据元素+引用下一个节点的引用+引用上一个节点的引用
			prev data next
		(6)链表是多个相互作用的节点的集合，整个链表总是从头节点开始，然后依次向后指向每个节点
		(7)空链表就是头节点为null的链表
		(8)单链表指的是每个节点只保留一个引用，该引用指向当前节点的下一个节点，没有引用指向头节点，尾节点的next引用为null
			data next->data next->..->data null
		(9)对于单链表，系统建立单链表的过程就是不断添加节点的过程，动态建立单链表有以下两种方式
			a.头插法建表:该方法从一个空表开始，不断地创建新节点，将数据元素存入节点的data域中，
				然后不断地以新节点为头节点，让新节点指向原有的头节点
			b.尾插法建表:该方法是将新节点插入到当前链表的表尾上，因此需要为链表定义一个引用变量来保存链表的最后一个节点
		(10)头插法建立链表虽然算法很简单，但生成的链表中节点的次序和输入的顺序相反，若希望二者次序一致，则应该采用尾插法来建立链表
		(11)对于单链表而言，常用的操作有: 查找 插入 删除
			a.查找操作 按序号查找第index个节点:从header节点依次向下在单链表中查找第index个节点
				算法为:设header为头，current为当前节点(初始时current从header开始)，0为头结点序号，i为计数器，则可使current依次下移寻找节点，
				并使i同时递增记录节点序号，直到返回指定节点
			b.在链表中查找指定的element元素，查找是否有等于给定值element的节点，若有，则返回首次找到的其值element的节点的索引，否则返回-1，
				查找过程从开始节点出发，顺着链表逐个将节点的值和给定值element做比较
			c.插入操作是将值为element的新节点插入到链表的第index个节点的位置上，因此，
				首先找到索引为index-1的节点，然后生成一个数据域为element的新节点newNode，
				并令index-1处节点的next引用新节点，新节点的next引用原来index处的节点
			d.删除操作是将链表的第index个节点删去，因为在单链表中，第index个节点是由index-1处的节点引用的，
				因此删除index处的节点将先获取index-1处的节点，然后让index-1处节点的next引用到原index+1处的节点，并释放index处的节点即可
		(12)掌握实现上面方法的思路之后，下面根据该思路采用Java语言来实现一个单链表
		(13)参见linkList
		(14)提供上面的LinkList类时，程序一样可以将其当成线性表来使用，下面程序测试了LinkList类的用法
	5)循环链表
		(1)循环链表是一种首尾相接的链表，将单链表的尾节点next指针改为引用单链表headerr节点，这个单链表就成了循环链表
		(2)循环链表具有一个显著特征，从链表的任一节点出发均可找到表中的其他所有节点，因此循环链表可以被视为"无头无尾"
			data next -> data next -> data next ->指向第一个data next
		(3)循环链表中的第一个节点之前就是最后一个节点，反之亦然，循环链表的无边界使得它实现许多方法时会更容易，在这样的链表上设计算法会比普通链表更加容易
		(4)新加入的节点应该是在第一个节点之前(采用头插法插入)，还是最后一个节点之后(采用尾插法插入)，可以根据实际要求灵活处理，具体的实现区别不大
		(5)就程序实现来说，循环链表与普通单链表差别并不大，保证链表中tail.next=header即可，因此此处不再给出循环链表的代码
		(6)除此之外，还有一种伪循环链表，就是在访问到最后一个节点之后的时候，手工地跳转到第一个节点，访问到第一个节点之前的时候也一样
			这样也可以实现循环链表的功能，当直接用循环链表比较麻烦或有可能有问题时，可以考虑这种伪循环链表
	6)双向链表
		(1)如果为每个保留两个引用prev和next，让prev指向当前节点的上一个节点，让next指向当前节点的下一个节点，此时的链表既可以向后依次访问每个节点
			也可以向前依次访问每个节点，这种形式的链表被成为双向链表，双线链表的示意图如
				<- prev data next ->
		(2)双向链表是一种对称结构，它克服了单链表上指针单向性的缺点，其中每个节点既可以向前引用，也可以向后引用，这样可以更方便地插入、删除数据元素
		(3)与单链表类似的是，如果将链表的header节点与tail节点链在一起就构成双向链表
		(4)双向链表的查找:
			a.由于双向链表既可以从header节点开始一次向后搜索每个节点，也可以从tail节点开始依次向前搜索每个节点
				因此当程序试图从双向链表中搜索指定索引处的节点时，既可以从该链表的header节点开始搜索，也可以从该链表的tail节点开始搜索
			b.至于到底应该从header开始搜索，还是应该从tail开始搜索，则取决于被搜索节点是更靠近header，还是更靠近tail
			c.一般来说，可以通过被搜索index的值来判断它更靠近header,还是更靠近tail，
				如果index<size/2,则可判断该位置更靠近header，应从header开始搜索，反之，则可判断该位置更靠近tail，那就应从tail开始搜索
		(5)双向链表的插入
			a.双向链表的插入操作更复杂，向双向链表中插入一个新节点必须同时修改两个方向的指针(即引用)
				<--> prev data next <-->prev data next <-->
		(6)双向链表的删除
			a.在双向链表中，删除一个节点也需要同时修改两个方向的指针，双向链表中删除节点的操作
				<-->prev data next <-->引用第三个data.prev   prev data next   引用第一个data.next<--> prev data next
		(7)掌握上面的理论之后，可以使用Java语言来实现一个双向链表，因为双向链表需要维护两个方向的指针，
			因此程序在添加节点、删除节点时都比维护普通的单链表更复杂
		(8)参见DuLinkList
		(9)从上面程序可以看出，由于双向链表需要同时维护两个方向的指针，因此添加节点、删除节点的指针维护成本更大，
			但双向链表具有两个方向的指针，因此可以向两个方向搜索节点，因此双向链表在搜索节点、删除指定索引处的节点时具有较好的性能
		(10)参见DuLinkListTest
	7)前面介绍了线性表的相关概念，并介绍了线性表的两种具体实现，顺序实现和链式实现，接下来，将对线性表的实现和功能做进一步分析
		(1)线性表的顺序和链式两种实现各有优势，具体对比如
			a.顺序表:
				空间性能:顺序表的存储空间是静态分布的，因此需要一个长度固定的数组，因此总有部分数组元素被浪费
				时间性能:顺序表中元素的逻辑顺序与物理存储顺序保持一致，而且支持随机存取，因此顺序表在查找、读取时性能很好
			b.链表
				空间性能:链表在存储空间是动态分布的，因此空间不会被浪费，但由于链表需要额外的空间来为每个节点保存指针，因此也要牺牲一部分空间
				时间性能:链表采用链式结构来保存表内元素，因此在插入、删除元素时性能较好
	8)线性表的功能
		(1)经过前面介绍，不难发现，线性表本质是一个充当容器的工具类，当程序有一组结构相同的数据元素需要保存时，就可以考虑使用线性表来保存它们
		(2)从某种程度来看，线性表是数组的加强，线性表比数组多了如下几个功能
			a.线性表的长度可以动态改变，而Java数组的长度是固定的
			b.线性表可以插入元素，而数组无法插入元素
			c.线性表可以删除元素，而数组无法删除元素，数组只能将指定元素赋为null，但各种元素依然存在
			d.线性表提供方法来搜索指定元素的位置，而数组一般不提供该方法
			e.线性表提供方法来清空所有元素，而数组一般不提供类似方法
		(3)从上面线性表的实现能发现线性表比数组功能强大的理由是，顺序结构的线性表可以说是包装过的数组，自然会提供更多额外的操作来简化操作
		(4)对于大部分Java程序员来说，其实经常在使用线性表List，Java的List接口就代表了线性表，线性表的两种实现分别是ArrayList和LinkedList
			其中LinkedList还是双向链表
		(5)虽然线性表对于编程非常重要，但对于Java程序员而言，像使用线性表的哪种实现就是用哪种实现，只要选择使用ArrayList还是LinkedList
