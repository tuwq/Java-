第五章: 表达式中的陷阱
总结:
	1)本章重点分析了Java表达式中的潜在陷阱
		(1)这些陷阱包含使用字符串时可能出现的陷阱
		(2)使用算术表达式时可能出现的表达式类型自动提升、复合赋值运算符的隐含转换等陷阱
		(3)使用中文输入法引用中文字符导致的错误
		(4)表达式中使用转义字符可能导致的错误
		(5)正则表达式中点号(.)可代表任意字符可能引起的错误
	2)详细介绍了泛型编程和多线程编程可能存在的错误
		(1)泛型和原始类型混用时更容易导致错误
		(2)多线程编程中则需要注意不要调用线程对象的run方法，静态同步方法，多线程执行环境等
			静态同步方法的同步监视器是当前类，而不是当前运行调用类
		(3)分析一个程序不能仅仅停留在静态的代码上，而是应该从程序执行过程来把握程序的运行细节
1.字符串的陷阱
	1)JVM对字符串的处理
		(1)String java=new String("疯狂Java")
			实际上创建了两个字符串对象，其中一个"疯狂Java"这个直接量对应的字符串对象
			另一个是由new String()构造器返回的字符串对象
		(2)Java程序中创建对象的常见方式有如下4种
			a.通过new调用构造器创建Java对象
			b.通过Class对象的newInstance()方法调用构造器创建Java对象
			c.通过Java的反序列化机制从IO流中恢复Java对象
			d.通过Java对象提供的clone()方法复制一个新的Java对象
			除此之外，字符串以及基本类型的包装类，Java还允许以直接量的方式来创建Java对象
			除此之外，也可通过简单的算术运算符、连接运算符来创建Java对象
		(3)字符串中都是字符串直接量，整数直接量、没有变量参与、没有方法调用，那么JVM可以在编译时就确定该字符串连接表达式的值
			a.String str="Hello"+"JAVA,"+"crazyit.org"
				这条代码只创建了一个字符串对象，因为str的值可以在编译时确定下来
				JVM会在编译时就计算出str的值为HelloJAVA,crazyit.org，然后将该字符串直接量放入字符串池中，并让str指向它
		(4)但如果程序使用了变量(宏变量除外)、调用了方法，就只能等到运行时才可确定该字符串连接表达式的值
			也就无法在编译时确定该字符串变量的值，因此无法利用JVM的字符串池
	2)不可变的字符串
		(1)String类是一个典型的不可变类，当一个String对象创建完成后，该String类里包含的字符序列就被固定下来
		(2)使用System提供的identityHashCode()静态方法可证实这一点，
			identityHashCode()静态方法用于获取某个对象唯一的hashCode值
			这个identityHashCode()方法的返回值与该类是否重写了hashCode()方法无关
			只有当两个对象相同时，它们的identityHashCode值才相等
		(3)如果程序需要一个字符序列会发生改变的字符串，那么应该使用StringBuild或StringBuffer
	3)字符串比较
		(1)如果程序需要比较两个字符串是否相同，用==进行判断就可以了
		(2)但如果要判断两个字符串所包含的字符序列是否相同，则应该用String重写过的equals()方法进行比较
		(3)比较大小时，使用compareTo()方法进行比较
2.表达式类型的陷阱
	1)表达式类型的自动提升
		(1)Java语言规定，当一个算术表达式中包含多个基本类型的值时，整个算术表达式的数据类型将自动提升
			a.所有的byte类型、short类型、char类型将被提升到int类型
			b.整个算术表达式的数据类型自动提升到与表达式中最高等级操作数同样的类型，
				byte->short(char)->int->long->float->double
			位于箭头右边的类型等级高于位于箭头左边的类型等级
	2)复合赋值运算符的陷阱
		(1)根据Java语言的规范，复合赋值运算符包含了一个隐式类型转换，也就是说，下面两条语句并不等价
			a=a+5;  不等价于 a+=5;
			实际上 a+=5 等价于 a=(a的类型)(a+5)
			这就是复合赋值运算符中包含的隐式类型转换
			E1 op=E2 不等价于 E1=E1 op E2;
			而是 E1=(E1的类型)(E1 op E2)
	3)Java7新增的二进制整数
		int it=0b1010_1010  byte bt=(byte)0b_1010_1010
		(1)这需要强制转换
		(2)原因有在于有如下两条规则
			a.直接使用整数直接量时，系统会将它当成int类型处理
			b.btye类型的整数虽然可以包含8位，但最高位是符号位
		(3)表面上看0b_1010_1010只占了8位，但它已经超出了byte的取值范围，因此程序将它强制转换为byte
		(4)把0b_1010_1010整数强制转换为byte类型时，其最高位的1表示它是一个负数，计算机以补码形式来保存所有的整数
		(5)正数的补码和原码相同，负数的补码等于反码加+1，把二进制数的除符号位之外的所有位按位取反即可得到反码
	4)输入法导致的陷阱
		(1)注意半角符号与全角符号的区别，否则将提示如"非法字符: \XXXX"的错误
	5)注释字符必须合法
		(1)大部分时候，Java编译器会直接忽略注释部分，但有一种情况例外
		(2)Java要求注释部分的所有字符必须是合法的字符
		(3)Java程序允许直接使用\uXXXX的形式代表字符，它要求\u后面的4个字符必须是0-F字符，而注释中包含如\unit5
			这不符合Java对Unicode转义字符的要求
	6)转义字符的陷阱
		(1)Java程序提供三种方式来表示字符
			a.直接使用单引号括起来的字符值
			b.使用转义字符，如 "\n"
			c.使用Unicode转义字符，如 "\u0062"，
		(2)慎用字符的Unicode转义形式,Java对待Unicode转义字符时不会进行任何处理，
			它会将Unicode转义字符直接替换成对应的字符.这将给Java程序带来一些潜在的陷阱
3.泛型可能引起的错误
	1)原始类型变量的赋值
		(1)对于initList<Integer>而言，编译器会认为该集合每个元素都是Integer类型，而尝试将集合元素赋给一个String类型的变量
			编译器会提示编译错误
		(2)这样的事情给出的教训有三点
			a.当程序把一个原始类型的变量赋个一个带泛型信息的变量时，总是可以通过编译，只是会提示一些警告信息
			b.当程序试图访问带泛型声明的集合的集合元素时，编译器总是把集合元素当成泛型类型处理-它并关心集合里集合元素的实际类型
			c.当程序试图访问带泛型声明的集合的集合元素时，JVM会遍历每个集合自动执行强制类型转换，如果集合元素的实际类型
				与集合所带的泛型信息不匹配，运行时将引发ClassCastException异常
	2)原始类型带来的擦除
		(1)将泛型对象赋给一个没有泛型声明的变量，此时将发生擦除
		(2)该泛型对象将丢失尖括号内所有的信息(泛型信息)，当不注意时，将提示"不兼容的类型"引起编译错误
4.正则表达式的陷阱
	1)注意一下两点
		(1)String提供的split(String regex)方法需要的参数是正则表达式
		(2)正则表达式中的点号(.)可匹配任意字符
		(3)Java中支持正则表达式的主要方法
			a. matches(String regex):判断该字符串是否匹配指定的正则表达式
			b. replaceAll(String regex,String replacement):将字符串中所有匹配指定的正则表达式的子串替换成replacement后返回
			c. split(String regex):以正则表达式匹配的子串作为分割符来分割该字符串
5.多线程的陷阱
	1)JDK提供三种方式来创建，启动多线程
		(1)继承Thread类来创建线程类，重写run()方法作为线程执行体
		(2)实现Runnable接口来创建线程类，重写run()方法作为线程执行体
		(3)实现Callable接口来创建线程类，重写call()方法作为线程执行体
	2)启动线程开始调用的是start()方法，而不是run()或call()方法
	3)静态的同步方法
		(1)静态同步方法可以和以this为同步监视器的同步代码块同时执行
		(2)静态同步方法的同步监视器是当前类，而不是当前运行调用类
		(3)静态代码块和非静态代码块可作为新线程的执行体
	4)注意多线程执行环境，对于实现多线程的类
		(1)该类的对象可以被多个线程安全地访问
		(2)每个线程调用该对象的任意方法之后都将得到正确的结果
		(3)每个线程调用该对象的任意方法之后，该对象状态依然保持合理状态