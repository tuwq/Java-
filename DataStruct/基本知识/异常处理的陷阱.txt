第八章 异常处理的陷阱
总结: 
	1)本章详细介绍了异常处理中可能遇到的陷阱，这些问题是大部分Java开发者经常遇到
		却又非常容易犯错的场景
	2)例如，如何正确地关闭物理资源，异常处理中使用finally块问题，try..catch流程中
		catch块处理不当引起的错误，希望读者能重视这些问题，在实际开发中避开它们
1.正确关闭资源的方式
	1)传统关闭资源的方式
		(1)关闭方式主要保证如下三点
			a.使用finally块来关闭物理资源，保证关闭操作总是会被执行
			b.关闭每个资源之前首先保证引用该资源的引用变量不为null
			c.为每个物理资源使用单独的try...catch块来关闭资源，
				保证关闭时引发的异常不会影响其他资源的关闭
	2)使用Java7增强的try语句关闭资源
		(1)如果按照传统的方式来关闭资源，必然会导致finally块代码十分臃肿，
			这样的代码必将导致程序的可读性降低，为了解决这个问题，
				Java7新增了自动关闭资源的try语句:
		(2)它允许在try关键字后紧跟一对圆括号，圆括号可以声明，初始化一个或多个资源，
			此处资源指的是那些必须在程序结束时显示关闭的资源(比如数据库连接、网络连接等)，
			try语句会在该语句结束时自动关闭这些资源
		(3)需要指出的是，为了保证try语句可以正常关闭资源，这些资源实现类必须实现
			AutoCloseable或Closeable接口，实现这两个接口就必须实现close()方法
		(4)参见AutoClose实现
		(5)自动关闭资源的try语句相当于包含了隐式的finally块(这个finally块用于关闭资源)
			因此这个try语句可以既没有catch块，也没有finally块
		(6)需要指出的是，使用自动关闭资源的try语句有两个注意点
			a.被自动关闭的资源必须实现Closeable或AutoClosable接口
			b.被自动关闭的资源必须放在try语句后的圆括号中声明、初始化
			如果程序需要，自动关闭资源的try语句后也可以带多个catch块和一个finally块
2.finally块的陷阱
	1)finally的执行规则
		(1)前面介绍说，finally块代表总是会被执行的代码块，但有一种情况例外
		(2)参见ExitFinally实现
		(3)无论try块是正常结束，还是中途非正常退出，finally块确实都会执行
			然而在这个程序中，try语句块根本就没有结束其执行过程
			System.exit(0)将停止当前线程和所有其他当场死亡的线程，
			finally块并不能让已经停止的线程继续执行
	2)当System.exit(0)被调用时，虚拟机退出前要执行两项清理工作
		(1)执行系统中注册的所有关闭钩子
		(2)如果程序调用了System.runFinalizerOnExit(true),那么JVM会对所有还未结束的对象调用Finalizer
			a.第二种方式已经被证明是极度危险的，因此JDK API文档中说明第二种方式已经过时了，因此实际开啊中不应该使用这种危险行为
			b.第一种方式则是一种安全的操作，程序可以将关闭资源的操作注册成为关闭钩子，
		在JVM退出之前，这些关闭钩子将会被调用，从而保证物理资源被正常关闭
	3)finally块和方法返回值
		(1)通过上面介绍可以看出，只要Java虚拟机不退出，不管try块正常结束，还是遇到异常非正常退出，
			finally块总会获得执行的机会
		(2)当程序执行try块、catch块遇到throw语句时，throw语句会导致该方法立刻结束
			系统执行throw语句时并不会立即抛出异常，而是去寻找该异常处理流程中是否包含finally块
			如果没有finally块，程序立即抛出异常，中止方法:
		(3)如果有finally块，系统立刻开始执行finally块，只有当finally块执行完成后，系统才会再次跳回来抛出异常、中止
			如果finally块里使用return语句来结束方法，系统将不会跳回try块去抛出异常、中止方法
3.catch块的用法
	1)Java语法规定，对于非自动关闭资源的try语句，每个try块至少需要一个catch块或一个finally块，
		绝不能只有单独一个孤零零的try块，一个try块不仅可以对应一个catch块，还可以对应多个catch块
	2)在通常情况下，如果try块被执行一次，则try块只有一个catch块会被执行，绝不可能有多个catch块被执行，
		除非在循环中使用了continue开始下一次循环，一下次循环又重新运行了try块，才可能导致多个catch块被执行
	3)由于异常处理机制中排在前面的catch(XxxException ex)块总是会优先获得执行的机会，
		因此Java对try块后的多个catch块的排列顺序是有要求的
		(1)因为Java的异常有非常严格的继承体系，许多异常类之间有严格的父子关系，比如
			程序FileNotFoundException异常就是IOException的子类，
		(2)根据Java继承的特性，子类其实是一种特殊的父类，也就是说，FileNotFoundException只是一种特殊的IOException.
			程序前面的catch块已经捕捉了IOException，这意味着FileNotFoundException作为子类已经被捕捉过了
			因此程序在后面再次试图捕捉FileNotFoundException纯属多此一举
		(3)经过上面的分析可以看出，在try块后使用catch块来捕捉多个异常时，程序应该小心多个catch块之间的顺序，
			捕捉基类异常的catch块都应该排在捕捉子类异常的catch块之后(简称为，先处理小异常，再处理大异常)，否则将出现编译错误
		(4)由于Exception是所有异常类的根基类，因此try..catch块应该把捕捉Exception的catch块排在所有catch块的最后面:
			否则，Java运行时将直接进入捕捉Exception的catch块(因为所有异常帝乡都是Exception或其派生类的实例)，
			而排在它后面的catch块将永远也不会获得执行的机会，
			当然，编译器还是比较智能的，当检测到程序员试图做这样一件"蠢事"时，编译器会直接提示编译错误，阻止这样的代码获得执行
4.不要用catch代替流程控制
	1)切记:千万不要使用异常来进行流程控制，异常机制不是为流程控制而准备的，而是为程序的意外情况准备的，因此程序只应该为异常情况使用异常机制，
		所以，不要使用这种"别出心裁"的方法来遍历数组
	2)只有catch可能抛出的异常
		(1)根据Java语言规范，如果一个catch块试图捕捉一个类型为XxxException的Checked异常，
			那么它对应的try块必须可能抛出XxxException或其子类的异常，否则编译器将提示该程序具有编译错误
		(2)但在所有的Checked异常中，Exception是一个异类，无论try块是怎样的代码,catch(Exception ex)总是正确
	3)实际上，如果一段代码可能抛出了Checked异常(这段代码调用的某个方法、构造器声明抛出了该Checked异常)，
		那么程序必须处理这个Checked异常，对于Checked异常的处理方式有两种
			(1)当前方法明确知道如何处理该异常，程序应该使用try..eatch块来捕捉该异常，然后在对应的catch块中修复该异常
			(2)当前方法不知道如何处理这种异常，应该在定义该方法时声明抛出该异常
	4)总之，程序使用catch块捕捉异常时，其实并不能随心所欲地捕捉所有异常，程序可以在任意想捕捉的地方捕捉RuntimeException异常，
		但对于其他Checked异常，只有当try块可能抛出该异常时(try块中调用的某个方法声明抛出了该Checked异常)，catch块才能捕捉该Checked异常
5.做点实际的修复
	1)对于前面介绍的绝大部分程序，程序的catch块里并未提供太多有效的修复操作，catch块内只有一行简单的ex.printStackTrace();代码
		其实这行代码并没有太多的存在价值，只是打印了异常的跟踪栈信息而已
	2)即使程序不捕捉该异常，不使用ex.printStackTrace()输出异常的跟踪栈信息，JVM遇到异常时也会自动中止程序，并打印了异常的跟踪栈信息
	3)如果程序知道应该如何修复指定的异常，则应该在catch块内尽量修复该异常，当该异常情况被修复后，可以再次调用该方法，
		如果程序不指定如何修复该异常，也没有进行任何修复，则千万不要再次调用可能导致该异常的方法
	4)无论如何不要在finally块中递归调用可能引起异常的方法，因为这将导致该方法的异常不能被正常抛出，甚至StackOverflowError错误也不能中止程序，
		只能采用强行结束java.exe进程的方法来中止程序的运行
6.继承得到的异常
	1)Java语言规定，派生类重写基类的方法时，不能声明抛出比基类方法方法类型更多、范围更大的异常，也就是说，派生类重写基类方法时，
		派生类方法只能声明抛出基类方法所抛出的异常的派生类
7.Java7增强的throw语句
	1)Java7会检查(1)代码可能抛出异常的实际类型
	因此该方法只需声明抛出FileNotFoundException异常即可
	2)throws FileNotFoundException
	3)ex.printStackTrance() throw ex;(1)
