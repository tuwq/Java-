第四章 Java的内存回收 上
总结:
	1)本章主要介绍了Java内存回收的相关知识
	2)首先从Java引用开始讲起
	3)Java引用和内存回收是紧密相关,只有当一个Java对象失去引用时，JVM才会考虑回收这个Java对象
	4)然后介绍了JDK提供的不同引用，分别是强引用、软引用、弱引用、虚引用，并详细介绍了不同引用类型的功能和用法差异
	5)由于JVM是否回收对象的标准是该对象是否被引用，因此当一个无用对象的引用没有被释放时，将会到会导致内存泄露，因此Java也会有内存泄露的问题、
	6)本章重点介绍了JVM垃圾回收细节，包括各种垃圾回收算法，堆内存的分代回收、堆内存中Young代、Old代和Permanent代的差异以及它们存放不同对象
	7)详细介绍了JVM回收不同代中对象所采用的不同算法
	8)最后，还介绍了JDK的几种常用的垃圾回收器，并详细讲解了这几种垃圾回收器底层的回收细节
1.jvm采用有向图管理内存中的对象
	1)对于jvm的垃圾回收机制来说，是否回收一个对象的标准在于
		(1)是否还有引用变量引用该对象
		(2)只要有引用对象引用该对象，垃圾回收机制就不会回收它
	2)Java对象被创建出来之后，垃圾回收机制会实时的监控每个对象的运行状态
		(1)包含对象的申请、引用、被引用、赋值等
	3)当垃圾回收机制实时地监控到某个对象不再被引用变量所引用时
		(1)垃圾回收机制就会回收它所占用的空间
	4)基本上，可以把jvm内存中的对象引用理解成一种有向图
		(1)把引用变量、对象都当成有向图的顶点
		(2)将引用关系当成图的有向边，有向边总是从引用端指向被引用Java对象
		(3)因为Java的所有对象都是由一条条线程创建出来的，因此可以把线程对象
			当成有向图的起始顶点
	5)对于单线程程序而言，整个程序只有一条main线程，
		(1)那么该图就是以main进程为顶点的有向图
		(2)在这个有向图中，main顶点可达的对象都处于可达状态，垃圾回收机制不会回收它们
		(3)如果某个对象在这个有向图中处于不可达状态，那么就认为这个对象不再被引用
		(4)接下来垃圾回收机制就会主动回收它了
	6)jvm的垃圾回收机制采用有向图方式来管理内存中的对象，因此可以方便地解决循环引用的问题
		(1)有三个对象相互引用 A->B B->C C->A,它们都没有失去引用
		(2)但只要从有向图的起始顶点(进程根)不可达它们，垃圾回收机制就会回收它们
	7)采用有向图来管理内存中的对象具有较高的精度，但缺点是效率较低
2.对象在内存中的状态
	1)可达状态
		(1)当一个对象被创建后，有一个以上的引用变量引用它
		(2)在有向图中可以从起始顶点导航到该对象，那么它就处于可达状态
		(3)程序可以通过引用变量来调用该对象的属性和方法
	2)可恢复状态
		(1)某个对象不再有任何引用变量引用它，它先进入可恢复状态
		(2)此时从有向图的起始顶点导航不能导航到该对象
		(3)在这种状态下，系统的垃圾回收机制准备回收该对象所占用的内存
		(4)在回收该对象之前，系统会调用可恢复状态对象的finalize方法进行资源管理
		(5)如果系统调用finalize方法重新让一个以上的引用变量引用该对象
		(6)则这个对象会再次变为可达状态，否则，该对象将进入不可达状态
	3)不可达状态
		(1)当对象的所有关联都被切断，且系统调用所有兑现过的finalize方法依然没有使该对象变成可达状态后
		(2)这个对象将永久性地失去引用，最后变成不可达状态
		(3)只有当一个对象处于不可达状态时，系统才会真正回收该对象所占用的资源
3.引用方式
	1)强引用
		(1)这是最常见的引用，程序创建一个对象，并把这个对象赋给一个引用变量，这个引用变量就是强引用
		(2)强引用是Java编程中广泛使用的引用类型，被强引用所引用的Java对象绝不会被垃圾回收机制回收
		(3)即使系统内存非常紧张，即使用有些Java对象以后永远不会被用到，jvm也不会回收被强引用所引用的Java对象
		(4)由于jvm肯定不会回收被强引用的所引用的Java对象，因此强引用是造成Java内存泄露的主要原因之一
	2)软引用
		(1)软引用需要通过SoftReference类来实现
		(2)当一个对象只具有软引用时，它有可能被垃圾回收机制回收
		(3)当系统内存空间足够时，它不会被系统回收，程序可以使用该对象
		(4)当系统内存不足时，系统将会回收它
		(5)软引用通常用于内存敏感的程序中，软引用是强引用很好的替代
		(6)如果系统堆内存空间紧张，那么使用软引用是一种较好的方案
		(7)可提高程序运行效率，避免垃圾回收
	3)弱引用
		(1)弱引用通过过WeakReference、WeakHashMap类实现
		(2)弱引用具有很大的不确定性，因为每次垃圾回收机制执行时都会回收弱引用所引用的对象
		(3)获取弱引用所引用的对象时，必须小心空指针异常
		(4)弱引用所引用的对象生存期更短
		(5)与软引用类似，但引用级别更低
		(6)对于只有弱引用对象，当系统垃圾回收机制运行时
		(7)无论系统内存是否足够，总会回收该对象所占用的内存
	4)虚引用
		(1)虚引用不能单独使用，必须和引用队列联合使用
		(2)虚引用通过PhantomReference类实现，它完全类似于没有引用
		(3)虚引用对对象本身没有太大影响，对象只有一个虚引用，那么它和没有引用的效果大致相同
		(4)主要作用是跟踪对象被垃圾回收的状态，系统无法通过虚引用来获得被引用的对象
		(5)引用队列由ReferenceQueue类来表示，它用于保存被回收后对象的引用
		(6)当把软引用、弱引用和引用队列联合使用时，系统回收对象时，将把被回收对象的引用添加到关联的引用队列中
		(7)虚引用在对象被释放之前就已经把引用添加到引用队列当中，这使得可以在对象被回收之前采取行动
		(8)程序通过检查与虚引用关联的引用队列中是否已经包含指定的虚引用，从而了解引用所引用的对象是否即将被回收
4.垃圾回收机制
	1)主要完成下面两件事
		(1)跟踪并监控每个Java对象，当某个对象处于不可达状态时，回收该对象所占用的内存
		(2)清理内存分配、回收过程中产生的内存碎片
5.垃圾回收的基本算法
	1)串行回收
		(1)无论多少个CPU，始终只有一个CPU来执行垃圾回收操作
	2)并行回收
		(1)把整个回收工作拆分成多部分，每部分只由一个CPU执行垃圾回收操作，从而让多个CPU并行回收
		(2)效率高，但增加内存碎片
	3)并发执行/应用程序停止
		(1)并发执行的垃圾回收不会导致应用程序暂停，但并发执行垃圾回收需要解决和应用程序的执行冲突
		(2)并发执行需要更多的堆内存
		(3)应用程序停止的垃圾回收方式在执行垃圾回收的同时会导致应用程序暂停
	4)压缩/不压缩
		(1)支持压缩的垃圾回收器会把所有活对象搬迁到一起，然后将之前占用的内存全部回收，为了减少内存碎片，
		(2)不压缩的垃圾回收器只是回收内存，这样回收的内存不是连续的，因此有较多的内存碎片
		(3)不压缩垃圾回收机制回收内存更快，而分配内存时更慢，且不发解决内存碎片问题
	5)复制
		(1)将堆内存分成两个相同的空间，从根(类似于前面介绍的有向图顶点)开始
		(2)访问每一个关联的可达对象，将空间A的可达对象全部复制到空间B，然后一次性回收整个空间
		(3)需要巨大的复制成本和较多的内存
	6)标记清除
		(1)垃圾回收器先从根开始访问所有的可达对象，将它们标记为可达对象
		(2)然后再遍历一次整个内存区域，对所有没有标记为可达对象的对象进行回收处理
		(3)无需进行大规模复制操作，而且内存利用率高
		(4)需要两次遍历堆内存空间，遍历成本较大
		(5)造成应用程序暂停的时间随堆空间的大小线性增大
		(6)垃圾回收回来的内存往往是不连续的，整理后的堆内存里碎片很多
	7)标记压缩
		(1)这是压缩回收方式，这种方式充分利用上述两种算法的有优点
		(2)垃圾回收器先从根开始访问所有的可达对象，将它们标记为可达状态
		(3)接下来垃圾回收器将这些活动对象搬迁在一起，这个过程成为内存压缩
		(4)然后垃圾回收机制再次回收那些不可达对象所占用的内存空间，这样就避免了回收产生内存碎片
