第四章 Java的内存回收
1.jvm采用有向图管理内存中的对象
	1)对于jvm的垃圾回收机制来说，是否回收一个对象的标准在于
		(1)是否还有引用变量引用该对象
		(2)只要有引用对象引用该对象，垃圾回收机制就不会回收它
	2)Java对象被创建出来之后，垃圾回收机制会实时的监控每个对象的运行状态
		(1)包含对象的申请、引用、被引用、赋值等
	3)当垃圾回收机制实时地监控到某个对象不再被引用变量所引用时
		(1)垃圾回收机制就会回收它所占用的空间
	4)基本上，可以把jvm内存中的对象引用理解成一种有向图
		(1)把引用变量、对象都当成有向图的顶点
		(2)将引用关系当成图的有向边，有向边总是从引用端指向被引用Java对象
		(3)因为Java的所有对象都是由一条条线程创建出来的，因此可以把线程对象
			当成有向图的起始顶点
	5)对于单线程程序而言，整个程序只有一条main线程，
		(1)那么该图就是以main进程为顶点的有向图
		(2)在这个有向图中，main顶点可达的对象都处于可达状态，垃圾回收机制不会回收它们
		(3)如果某个对象在这个有向图中处于不可达状态，那么就认为这个对象不再被引用
		(4)接下来垃圾回收机制就会主动回收它了
	6)jvm的垃圾回收机制采用有向图方式来管理内存中的对象，因此可以方便地解决循环引用的问题
		(1)有三个对象相互引用 A->B B->C C->A,它们都没有失去引用
		(2)但只要从有向图的起始顶点(进程根)不可达它们，垃圾回收机制就会回收它们
	7)采用有向图来管理内存中的对象具有较高的精度，但缺点是效率较低
2.对象在内存中的状态
	1)可达状态
		(1)当一个对象被创建后，有一个以上的引用变量引用它
		(2)在有向图中可以从起始顶点导航到该对象，那么它就处于可达状态
		(3)程序可以通过引用变量来调用该对象的属性和方法
	2)可恢复状态
		(1)某个对象不再有任何引用变量引用它，它先进入可恢复状态
		(2)此时从有向图的起始顶点导航不能导航到该对象
		(3)在这种状态下，系统的垃圾回收机制准备回收该对象所占用的内存
		(4)在回收该对象之前，系统会调用可恢复状态对象的finalize方法进行资源管理
		(5)如果系统调用finalize方法重新让一个以上的引用变量引用该对象
		(6)则这个对象会再次变为可达状态，否则，该对象将进入不可达状态
	3)不可达状态
		(1)当对象的所有关联都被切断，且系统调用所有兑现过的finalize方法依然没有使该对象变成可达状态后
		(2)这个对象将永久性地失去引用，最后变成不可达状态
		(3)只有当一个对象处于不可达状态时，系统才会真正回收该对象所占用的资源
3.引用方式
	1)强引用
		(1)这是最常见的引用，程序创建一个对象，并把这个对象赋给一个引用变量，这个引用变量就是强引用
		(2)强引用是Java编程中广泛使用的引用类型，被强引用所引用的Java对象绝不会被垃圾回收机制回收
		(3)即使系统内存非常紧张，即使用有些Java对象以后永远不会被用到，jvm也不会回收被强引用所引用的Java对象
		(4)由于jvm肯定不会回收被强引用的所引用的Java对象，因此强引用是造成Java内存泄露的主要原因之一
	2)软引用
		(1)软引用需要通过SoftReference类来实现
		(2)当一个对象只具有软引用时，它有可能被垃圾回收机制回收
		(3)当系统内存空间足够时，它不会被系统回收，程序可以使用该对象
		(4)当系统内存不足时，系统将会回收它
		(5)软引用通常用于内存敏感的程序中，软引用是强引用很好的替代
		(6)如果系统堆内存空间紧张，那么使用软引用是一种较好的方案
		(7)可提高程序运行效率，避免垃圾回收
	3)弱引用
		(1)弱引用通过过WeakReference、WeakHashMap类实现
		(2)弱引用具有很大的不确定性，因为每次垃圾回收机制执行时都会回收弱引用所引用的对象
		(3)获取弱引用所引用的对象时，必须小心空指针异常
		(4)弱引用所引用的对象生存期更短
		(5)与软引用类似，但引用级别更低
		(6)对于只有弱引用对象，当系统垃圾回收机制运行时
		(7)无论系统内存是否足够，总会回收该对象所占用的内存
	4)虚引用
		(1)虚引用不能单独使用，必须和引用队列联合使用
		(2)虚引用通过PhantomReference类实现，它完全类似于没有引用
		(3)虚引用对对象本身没有太大影响，对象只有一个虚引用，那么它和没有引用的效果大致相同
		(4)主要作用是跟踪对象被垃圾回收的状态，系统无法通过虚引用来获得被引用的对象
		(5)引用队列由ReferenceQueue类来表示，它用于保存被回收后对象的引用
		(6)当把软引用、弱引用和引用队列联合使用时，系统回收对象时，将把被回收对象的引用添加到关联的引用队列中
		(7)虚引用在对象被释放之前就已经把引用添加到引用队列当中，这使得可以在对象被回收之前采取行动
		(8)程序通过检查与虚引用关联的引用队列中是否已经包含指定的虚引用，从而了解引用所引用的对象是否即将被回收
4.垃圾回收机制
	1)主要完成下面两件事
		(1)跟踪并监控每个Java对象，当某个对象处于不可达状态时，回收该对象所占用的内存
		(2)清理内存分配、回收过程中产生的内存碎片
5.垃圾回收的基本算法
	1)串行回收
		(1)无论多少个CPU，始终只有一个CPU来执行垃圾回收操作
	2)并行回收
		(1)把整个回收工作拆分成多部分，每部分只由一个CPU执行垃圾回收操作，从而让多个CPU并行回收
		(2)增加内存碎片
	3)并发执行/应用程序停止
		(1)并发执行的垃圾回收不会导致应用程序暂停，但并发执行垃圾回收需要解决和应用程序的执行冲突
		(2)并发执行需要更多的堆内存
		(3)应用程序停止的垃圾回收方式在执行垃圾回收的同时会导致应用程序暂停
	4)压缩/不压缩/复制
6)堆内存的分代回收
	