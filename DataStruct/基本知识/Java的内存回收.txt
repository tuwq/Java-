第四章 Java的内存回收
总结:
	1)本章主要介绍了Java内存回收的相关知识
	2)首先从Java引用开始讲起
	3)Java引用和内存回收是紧密相关,只有当一个Java对象失去引用时，JVM才会考虑回收这个Java对象
	4)然后介绍了JDK提供的不同引用，分别是强引用、软引用、弱引用、虚引用，并详细介绍了不同引用类型的功能和用法差异
	5)由于JVM是否回收对象的标准是该对象是否被引用，因此当一个无用对象的引用没有被释放时，将会到会导致内存泄露，因此Java也会有内存泄露的问题、
	6)本章重点介绍了JVM垃圾回收细节，包括各种垃圾回收算法，堆内存的分代回收、堆内存中Young代、Old代和Permanent代的差异以及它们存放不同对象
	7)详细介绍了JVM回收不同代中对象所采用的不同算法
	8)最后，还介绍了JDK的几种常用的垃圾回收器，并详细讲解了这几种垃圾回收器底层的回收细节
1.jvm采用有向图管理内存中的对象
	1)对于jvm的垃圾回收机制来说，是否回收一个对象的标准在于
		(1)是否还有引用变量引用该对象
		(2)只要有引用对象引用该对象，垃圾回收机制就不会回收它
	2)Java对象被创建出来之后，垃圾回收机制会实时的监控每个对象的运行状态
		(1)包含对象的申请、引用、被引用、赋值等
	3)当垃圾回收机制实时地监控到某个对象不再被引用变量所引用时
		(1)垃圾回收机制就会回收它所占用的空间
	4)基本上，可以把jvm内存中的对象引用理解成一种有向图
		(1)把引用变量、对象都当成有向图的顶点
		(2)将引用关系当成图的有向边，有向边总是从引用端指向被引用Java对象
		(3)因为Java的所有对象都是由一条条线程创建出来的，因此可以把线程对象
			当成有向图的起始顶点
	5)对于单线程程序而言，整个程序只有一条main线程，
		(1)那么该图就是以main进程为顶点的有向图
		(2)在这个有向图中，main顶点可达的对象都处于可达状态，垃圾回收机制不会回收它们
		(3)如果某个对象在这个有向图中处于不可达状态，那么就认为这个对象不再被引用
		(4)接下来垃圾回收机制就会主动回收它了
	6)jvm的垃圾回收机制采用有向图方式来管理内存中的对象，因此可以方便地解决循环引用的问题
		(1)有三个对象相互引用 A->B B->C C->A,它们都没有失去引用
		(2)但只要从有向图的起始顶点(进程根)不可达它们，垃圾回收机制就会回收它们
	7)采用有向图来管理内存中的对象具有较高的精度，但缺点是效率较低
2.对象在内存中的状态
	1)可达状态
		(1)当一个对象被创建后，有一个以上的引用变量引用它
		(2)在有向图中可以从起始顶点导航到该对象，那么它就处于可达状态
		(3)程序可以通过引用变量来调用该对象的属性和方法
	2)可恢复状态
		(1)某个对象不再有任何引用变量引用它，它先进入可恢复状态
		(2)此时从有向图的起始顶点导航不能导航到该对象
		(3)在这种状态下，系统的垃圾回收机制准备回收该对象所占用的内存
		(4)在回收该对象之前，系统会调用可恢复状态对象的finalize方法进行资源管理
		(5)如果系统调用finalize方法重新让一个以上的引用变量引用该对象
		(6)则这个对象会再次变为可达状态，否则，该对象将进入不可达状态
	3)不可达状态
		(1)当对象的所有关联都被切断，且系统调用所有兑现过的finalize方法依然没有使该对象变成可达状态后
		(2)这个对象将永久性地失去引用，最后变成不可达状态
		(3)只有当一个对象处于不可达状态时，系统才会真正回收该对象所占用的资源
3.引用方式
	1)强引用
		(1)这是最常见的引用，程序创建一个对象，并把这个对象赋给一个引用变量，这个引用变量就是强引用
		(2)强引用是Java编程中广泛使用的引用类型，被强引用所引用的Java对象绝不会被垃圾回收机制回收
		(3)即使系统内存非常紧张，即使用有些Java对象以后永远不会被用到，jvm也不会回收被强引用所引用的Java对象
		(4)由于jvm肯定不会回收被强引用的所引用的Java对象，因此强引用是造成Java内存泄露的主要原因之一
	2)软引用
		(1)软引用需要通过SoftReference类来实现
		(2)当一个对象只具有软引用时，它有可能被垃圾回收机制回收
		(3)当系统内存空间足够时，它不会被系统回收，程序可以使用该对象
		(4)当系统内存不足时，系统将会回收它
		(5)软引用通常用于内存敏感的程序中，软引用是强引用很好的替代
		(6)如果系统堆内存空间紧张，那么使用软引用是一种较好的方案
		(7)可提高程序运行效率，避免垃圾回收
	3)弱引用
		(1)弱引用通过过WeakReference、WeakHashMap类实现
		(2)弱引用具有很大的不确定性，因为每次垃圾回收机制执行时都会回收弱引用所引用的对象
		(3)获取弱引用所引用的对象时，必须小心空指针异常
		(4)弱引用所引用的对象生存期更短
		(5)与软引用类似，但引用级别更低
		(6)对于只有弱引用对象，当系统垃圾回收机制运行时
		(7)无论系统内存是否足够，总会回收该对象所占用的内存
	4)虚引用
		(1)虚引用不能单独使用，必须和引用队列联合使用
		(2)虚引用通过PhantomReference类实现，它完全类似于没有引用
		(3)虚引用对对象本身没有太大影响，对象只有一个虚引用，那么它和没有引用的效果大致相同
		(4)主要作用是跟踪对象被垃圾回收的状态，系统无法通过虚引用来获得被引用的对象
		(5)引用队列由ReferenceQueue类来表示，它用于保存被回收后对象的引用
		(6)当把软引用、弱引用和引用队列联合使用时，系统回收对象时，将把被回收对象的引用添加到关联的引用队列中
		(7)虚引用在对象被释放之前就已经把引用添加到引用队列当中，这使得可以在对象被回收之前采取行动
		(8)程序通过检查与虚引用关联的引用队列中是否已经包含指定的虚引用，从而了解引用所引用的对象是否即将被回收
4.垃圾回收机制
	1)主要完成下面两件事
		(1)跟踪并监控每个Java对象，当某个对象处于不可达状态时，回收该对象所占用的内存
		(2)清理内存分配、回收过程中产生的内存碎片
5.垃圾回收的基本算法
	1)串行回收
		(1)无论多少个CPU，始终只有一个CPU来执行垃圾回收操作
	2)并行回收
		(1)把整个回收工作拆分成多部分，每部分只由一个CPU执行垃圾回收操作，从而让多个CPU并行回收
		(2)效率高，但增加内存碎片
	3)并发执行/应用程序停止
		(1)并发执行的垃圾回收不会导致应用程序暂停，但并发执行垃圾回收需要解决和应用程序的执行冲突
		(2)并发执行需要更多的堆内存
		(3)应用程序停止的垃圾回收方式在执行垃圾回收的同时会导致应用程序暂停
	4)压缩/不压缩
		(1)支持压缩的垃圾回收器会把所有活对象搬迁到一起，然后将之前占用的内存全部回收，为了减少内存碎片，
		(2)不压缩的垃圾回收器只是回收内存，这样回收的内存不是连续的，因此有较多的内存碎片
		(3)不压缩垃圾回收机制回收内存更快，而分配内存时更慢，且不发解决内存碎片问题
	5)复制
		(1)将堆内存分成两个相同的空间，从根(类似于前面介绍的有向图顶点)开始
		(2)访问每一个关联的可达对象，将空间A的可达对象全部复制到空间B，然后一次性回收整个空间
		(3)需要巨大的复制成本和较多的内存
	6)标记清除
		(1)垃圾回收器先从根开始访问所有的可达对象，将它们标记为可达对象
		(2)然后再遍历一次整个内存区域，对所有没有标记为可达对象的对象进行回收处理
		(3)无需进行大规模复制操作，而且内存利用率高
		(4)需要两次遍历堆内存空间，遍历成本较大
		(5)造成应用程序暂停的时间随堆空间的大小线性增大
		(6)垃圾回收回来的内存往往是不连续的，整理后的堆内存里碎片很多
	7)标记压缩
		(1)这是压缩回收方式，这种方式充分利用上述两种算法的有优点
		(2)垃圾回收器先从根开始访问所有的可达对象，将它们标记为可达状态
		(3)接下来垃圾回收器将这些活动对象搬迁在一起，这个过程成为内存压缩
		(4)然后垃圾回收机制再次回收那些不可达对象所占用的内存空间，这样就避免了回收产生内存碎片
6.堆内存的分代回收
	1)分代回收的一个依据就是对象生存时间的长短，然后根据不同代采取不同不同的垃圾回收策略
	2)采用这种"分代回收"的策略基于如下两点事实
		(1)绝大对数的对象不会被长时间引用，这些对象在其Young期间就会被回收
		(2)很老的对象(生存时间很长)和很新的对象(生存时间很短)之间很少存在相互作用的情况
		(3)上面两点事实不仅在Java语言中如此，其他面向对象的编程语言也大致遵循这两个事实
	3)对于Young代的对象而言，大部分对象都会很快就进入不可达状态，只有少量的对象能熬到垃圾回收执行时
		(1)垃圾回收器只需要保留Young代中处于可达状态的对象
		(2)如此一来，采用复制算法只需要少量复制成本，因此大部分垃圾回收器对Young代都采用复制算法
	4)Young代
		(1)对Young代采用复制算法只需要遍历那些处于可达状态的对象，而且这些对象的数量较少，可复制成本也不大
		(2)Young代由一个Eden区和两个Survivor区构成，绝大多数对象先分配到Eden区中(有一些大对象可能会直接被分配到Old代)
		(3)Survivor区中的对象都至少在Young代中经历过一次垃圾回收
		(4)所以这些对象在被转移到Old代之前会先保留在Survivor空间
		(5)同一时间两个Survivor空间中有一个用来保存对象，而另一个是空的，用来保存垃圾回收时保存Young代中的对象
		(6)每次复制就是将Eden和第一个Survivor区的可达对象复制到第二个Survivor区
		(7)然后清空Eden与第一个Survivor区
		(8)Eden和Survivor区的比例通过-XX:SurvivorRatio附加选项来设置，默认为32
		(9)如果Survivor区太大则会产生浪费，太小则会使一些Young代的对象提前进入Old代
	5)Old代
		(1)如果Young代中的对象经过数次垃圾回收依然没有被回收掉，即这个对象经过足够长的时间还处于可达状态
		(2)垃圾回收机制就会将这个对象转移到Old代
		(3)Old代的大部分对象都是"久经考验"的"老人"了，因此它们没那么容易死
		(4)随着时间的流逝，Old代的对象越来越多，所以Old代的空间要比Young代的空间更大
		(5)old代的垃圾回收具有如下两个特征
			a.Old代垃圾回收的执行频率无须太高，因为很少有对象会死掉
			b.每次对Old代执行垃圾回收都需要更长的时间来完成
		(6)基于以上考虑，垃圾回收器通常会使用标记压缩算法，避免复制Old代大量对象，
			由于Old代对象不会很快死亡，也不会产生大量内存碎片
	6)Permanent代
		(1)Permanent代主要用于装载Class、方法等信息，默认为64MB
		(2)垃圾回收机制通常不会回收Permanent代中的对象
		(3)对于那些需要加载很多类的服务器程序，往往需要加大Permanent代的内存，否则可能会因为内存不足而导致程序终止
	7)当Young代的内存将要用完时，垃圾回收机制会对Young代进行垃圾回收，垃圾回收机制会采用较高的频率对Young进行扫描，被称为次要回收
	8)当Old代的内存将要用完时，垃圾回收机制会进行全回收，Young和Old都进行回收，被称为主要回收
7.常见的垃圾回收器
	1)串行回收器
		(1)串行回收器通过运行Java程序时使用-XX:+UseSerialGC附加选项启用
		(2)串行回收器对Young代和Old代的回收的都是串行的(只是用一个CPU)
		(3)而且垃圾回收期间会使得应用程序产生暂停
		(4)Young代采用串行复制算法，Old代采用串行标记压缩算法
	2)并行回收器
		(1)并行回收器通过运行Java程序时使用-XX:+UseParallelGC附加选项启用
		(2)并行回收器对于Young代采用与串行回收器基本相似的回收算法，只是增加了多CPU并行的能力
		(3)线程数默认为CPU个数，当计算机中的CPU很多时，可以用-XX:ParallelGCThreads=size来减少并行线程的数目
		(4)并行回收器对于Old代采用与串行回收器完全相同的回收算法，不管有计算机有几个CPU，依然采用单线程、标记整理回收
	3)并行压缩回收器
		(1)并行压缩回收器通过运行Java程序时使用-XX:+UserParallelOldGC附加选项启用，一样可设置并行线程数量
		(2)它与并行回收最大不同是对Old代的回收使用了不同的算法
		(3)最终会取代并行回收器
		(4)主要改变体现在Old代的回收上
			a.系统首先将Old代划分成几个固定大小的区域，在mark阶段，多个垃圾回收线程会并行标记Old代中的可达对象
				当某个对象被标记成可达对象时，还会更新该对象所在区域的大小，以及该对象的位置信息
			b.接下来是summary阶段,summary阶段直接操作Old代的区域，而不是单个对象
				由于每次垃圾回收的压缩都会在Old代的左边部分存储大量的可达对象，对这样高密度的可达对象区域进行压缩往往很不划算
				所以summary阶段从最左边的区域开始检测每个区域的密度，
				当检测到某个区域能回收的空间达到某个数值时(也就是可达对象的密度较小时)
				垃圾回收器会判定该区域，以及该区域的右边的所有区域都应该进行回收
				而该区域的左边的区域都会被标识为密集区域
				垃圾回收器既不会把新对象移动到这些密集区域，也不会对该密集区域进行压缩
				该区域和其右边的所有区域都会被压缩并回收空间
				summary阶段目前还是串行操作，虽然并行是可以实现的，但重要性不如对mark和压缩阶段的并行重要
			c.最后是compact阶段，回收器利用summary阶段生成的数据识别出有哪些区域是需要装填的，
				多个垃圾回收线程可以并行地将数据复制到这些区域中，经过这个过程后，
				Old代的一端会密集地存在大量的活动对象，另一端则存在大块的空闲块
	4)并发标识-清理回收器(CMS)
		(1)并发标识-清理回收器通过运行Java程序时使用-XX:+UseConcMarkSweepGC附加选项启用
		(2)CMS回收器对Young代的回收方式和并行回收器的回收方式完全相同
		(3)由于对Young代的回收依然采用复制回收算法，因此垃圾回收时依然会导致程序暂停，除非依靠多CPU并行来提高垃圾回收速度
		(4)CMS对Old代的回收多数是并发操作，而不是并行操作。
			a.垃圾回收开始时需要一个短暂的暂停，此阶段称为初始阶段(mark)，这个阶段仅仅表示出那些被直接引用的对象
			b.接下来进入并发标识阶段，垃圾回收器会依据在初始标识中发现的可达对象来寻找其他的可达对象
			c.由于在并发标识阶段应用程序也会同时运行，无法保证所有的可达对象都被标识出来
				因此应用程序会再次很短地暂停一下，多线程并行地重新标识之前可能因为并发而漏掉的对象
				这个阶段被成为再标识阶段
		(5)CMS回收器的最大改进在于对Old代的回收，它只需两次短暂的暂停，
			而其他过程都是与应用程序并发执行的，因此对实时性要求较高的程序更合适
		(6)对于串行、标记压缩回收器而言，它可以等到Old代满了之后再开始回收，反正垃圾回收器总会让应用程序暂停
		(7)但CMS回收器要与应用程序并发运行，如果Old代满了才开始回收，那么应用程序将无内存可用，
			所以系统默认在Old代68%满的时候就开始回收
		(8)CMS不会进行内存压缩，也就是，不可达对象占用的内存被回收以后，垃圾回收器不会移动可达对象占用的内存
		(9)由于Old代的可用空间不是连续的，因此CMS垃圾回收器必须保存一份可用空间的列表
			当需要分配对象时，垃圾回收器就要通过这份列表找到容纳新对象的空间
			这样就会使得分配内存时的效率下降，从而影响了Young代回收过程中将Young代对象移动到Old代的效率
		(10)对于CMS回收器而言，当垃圾回收器执行并发标识时，应用程序在运行的同时也在分配对象，
			因此Old代也同时在增长，而且，虽然可达对象在标识阶段会被标识阶段会被识别出来
			但有些在标识阶段成为垃圾的对象并不能立即被回收，只有等下次垃圾回收时才能被回收，
			因此CMS回收器较之前面的几种回收器需要更大的堆内存
		(11)对于Permanent代内存，CMS可通过运行Java程序时使用-XX:CMSClassUnloading-Enabled附加选项来强制回收Permanent代内存
8.内存管理小技巧
	1)尽量使用直接量
		(1)String str="Hello"
		此时创建一个hello字符串，而且jvm的字符串缓存池还会缓存这个字符串
		(2)String str=new String("Hello")
		此时程序同样创建了一个缓存在字符串缓存池中的Hello字符串
		除此之外，str所引用的String对象底层还包含了一个char[]数组，这个数组依次存放了H、e、l、l、o
	2)使用StringBuilder和StirngBuffer进行字符串连接
		(1)String、StringBuilder、StirngBuffer都可代表字符串
		(2)String代表字符序列不可变的字符串，而StringBuilder、StirngBuffer都代表字符序列可变的字符串
		如果程序使用多个String对象进行字符串连接运算，在运行时将生成大量的临时字符串
		这些字符串会保存在内存中从而导致程序性能下降
	3)尽早释放无用对象的引用
		(1)大部分时候，方法的局部引用变量所引用的对象会随着方法的结束而变成垃圾
		(2)因为局部变量的生存期限更短，当方法运行结束时，该方法内的局部变量就结束了生存期限
		(3)大部分时候程序无须将局部引用变量显式设为null
		(4)但当方法结束前还需要执行耗时、耗内存操作或调用耗时、耗内存方法时，那么显式设为null就很有必要
	4)尽量少用静态变量
		(1)从理论上来说，Java对象何时被回收由垃圾回收机制决定，对程序员来说是不确定的
		(2)垃圾回收机制判断一个对象是否是垃圾的唯一标准就是该对象是否有引用变量引用它，因此推荐尽早释放对象的引用
		(3)最坏情况是，某个对象被static变量所引用，那么垃圾回收机制通常是不会回收这个对象所占的内存的
		(4)static Object obj=new Object 只要obj变量还引用它，它就不会被垃圾回收机制所回收
	5)避免在经常调用的方法，循环中创建Java对象
		(1)在循环中会重复创建对象，且这些对象的生存时间并不长，接下来系统又需要回收它们所占的内存空间，使得程序的性能受到巨大影响
	6)缓存经常使用的对象
		(1)有些对象需要被经常调用，则可以考虑把这些对象用缓存池保存起来
		(2)这样当下次需要时就可直接拿出这些对象来用，典型的缓存就是数据连接池和redis
		(3)如果直接使用HashMap进行缓存，程序员需要手动控制HashMap容器里的key-value对不至于太多，因为太多会占用过大的内存
	7)尽量不要使用finalize方法
		(1)前面介绍垃圾回收机制时已经提到，在一个对象失去引用之后，垃圾回收器准备回收该对象之前
		(2)垃圾回来机制会先调用该对象的finalize()方法来执行资源清理，基于这种考虑，可能有些开发者会考虑使用finalize()方法来进行资源清理
		(3)实际上，将资源清理放在finalize()方法中完成是非常拙劣的的选择，根据前面介绍的垃圾回收算法，垃圾回收机制的工作量已经够大了
			尤其是回收Young代内存时，大都会引起应用程序暂停，使得用户难以忍受
		(4)在垃圾回收器本身已经严重制约应用程序性能的情况下，如果在选择使用finalize()方法进行资源清理，无疑是一种火上浇油的行为，
			这将导致垃圾回收器的负担更大，导致程序运行效率更差
	8)考虑使用SoftReference
		(1)当程序需要创建长度很大的数组时，可以考虑使用SoftReference来包装数组元素，而不是直接让数组元素来引用对象
		(2)SoftReference是一个很好的选择:当内存足够时，它的功能等同于普通引用，当内存不够时，它会牺牲自己，释放软引用所引用的对象
		(3)使用软引用引用对象时不要忘记软引用的不确定性，因此应用程序取出SoftReference所引用的Java对象之后，
			应该显式判断该对象是否为null，当该对象为null，应重建该对象