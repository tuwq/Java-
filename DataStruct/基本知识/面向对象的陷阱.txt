第七章 面向对象的陷阱 上
总结:
	1)本章主要介绍了Java面向对象编程中可能出现的错误，包括使用instanceof运算符可能引起的错误
	2)很多开发者对Java构造器存在的误解，例如，构造器到底是否创建对象等
	3)本章还介绍了JVM如何区分多个重载方法，native方法跨平台可能有问题
	4)private访问权限的方法不能被重写，包访问权限的方法也可能无法被重写等有关方法的陷阱
	5)本章另一个重点讲解的内容是static关键字，包含static的作用是将类中定义的成员变成静态成员
	6)使用非静态内部类的诸多限制，以及使用静态内部类的限制等
1.instanceof运算符的陷阱
	1)instanceof一个非常简单的运算符，instanceof运算符
		(1)前一个操作数通常是一个引用类型的变量，后一个操作数通常一个类，也可以是接口
		(2)可以把接口理解成一种特殊的类
	2)它用于判断前面的对象是否是后面的类或其子类、实现类的实例
		(1)如果是，则返回true,否则返回false
	3)这个运算符的用法看似很简单，实际上使用该运算符往往并不简单
		(1)System.out.println("字符串是否是Math类的实例":
								+(str instanceof Math));
	4)上面的程序中粗体字代码无法通过编译，如果尝试编译上面的Java程序，将看到编译器提示如下编译错误
		(1)InstanceofTest.java.26:不可转换的类型
		   找到:java.lang.String
		   需要:java.lang.Math
		   				 +(str instanceof Math);
	5)很明显，该程序的这个地方并不能使用instanceof运算符
	6)根据Java语言规范，使用instanceof运算符有一个限制:
		(1)instanceof运算符前面的操作数的编译类型必须是如下三种情况
			a.要么与后面的类相同
			b.要么是后面类的基类
			c.要么是后面类的派生类
		(2)在极端情况下，instanceof前一个操作数所引用对象的实际类型就是后面的类型
			但只要它的编译时类型既不是第二个操作数的类型，也不是第二个操作数的基类、派生类，程序就没法通过编译
	7)对于Java的强制转型而言，也可以分为编译、运行两个阶段来分析它
		(1)在编译阶段，强制转型要求被转型变量的编译时类型必须是如下三种情况之一
			a.被转型变量的编译时类型与目标类型相同
			b.被转型变量的编译时类型是目标类型基类
			c.被转型变量的编译时类型是目标类型的派生类，在这种情况下可以进行自动向上转型，无须强制转换
		(2)如果被转型变量的编译时类型与目标类型没有任何继承关系，编译器将提示编译错误
			a.强制转型的编译阶段只关心引用变量的编译时类型，至于该引用变量实际引用对象的类型，编译器并不关心，也没法关心
		(3)在运行阶段，被转型变量所引用对象的实际类型必须是目标类型的实例，
			a.或者是目标类型的派生类、实现类的实例，否则在运行时将引用ClassCastException异常
		(4)	Object obj="疯狂Java讲义"
			String objStr=(String)obj		//(1)
			Object objPri=new Integer(5);
			String str=(String)objPri		//(2)
			String s="疯狂Java讲义"
		    Math m=(Math)s					//(3)
		    a.(1)行代码一切正常，可以通过编译，运行时也没有问题，因为obj的编译时类型是Object，它是String的基类，因此可以通过编译
		    	obj所引用的对象实际上就是String对象，因此将它转换为String类型没有任何问题
		    b.(2)行代码可以通过编译，但会引发ClassCastException异常，因为objPri的编译时类型是Object.它是String的父类，所以可以通过编译
		    	但objPri所引用的对象实际上是Integer对象，因此尝试将它转换为String会引发ClassCastException异常
		    c.(3)行代码将导致编译错误，因为s的编译时类型是String,该类型既不是Math类型，也不是Math的父类，还不是Math的子类，因此无法通过编译
	8)关于instanceof还有一个比较隐蔽的陷阱
		(1)String s=null;
		(2)s instanceof String
		上面程序定义了一个String类型的s变量，该s变量引用一个null对象，接着程序判断s instanceof String的结果
		尝试编译该程序，一切正常，这表明该程序完全可以通过编译
		尝试运行该程序，程序输出false
		虽然null可以作为所有引用类型变量的值，但对于s引用变量而言，它实际上并未引用一个真正的String对象，因此程序输出false
	9)使null调用instanceof运算符返回false是非常有用的行为，因为instanceof运算符有了一个额外的功能
		(1)它可以保证第一个操作数所引用的对象不是null
		(2)如果instanceof告知一个引用变量是某个特定类型的实例，那么就可以将其转型为该类型，并调用该类型的方法
		(3)因此不用担心会抛出ClassCastException或NullPointException异常
2.构造器的陷阱
	1)构造器之前的void
		(1)构造器是有返回值的，构造器返回它初始化的Java对象(用new调用构造器就可以看到构造器的返回值)
		(2)也就是说，构造器的返回值类型总是当前类
		(3)即使不讨论构造器是否有返回值的问题，也有一点是可以确定的，构造器不能声明返回值的类型，也不能使用void声明构造器没有返回值
		(4)当为构造器声明添加任何返回值类型声明，或者添加void声明该构造器没有返回值时，编译器并不会提示这个构造器有错误，
			只是系统会把这个所谓的"构造器"当成普通方法处理
	2)构造器创建对象吗
		(1)大部分Java书籍、资料都笼统地说，通过构造器来创建一个Java对象，这样很容易给人一种感觉，构造器负责创建Java对象
		(2)但实际上构造器并不会创建Java对象，构造器只是负责执行初始化，在构造器执行之前，Java对象所需要的内存空间
		(3)应该说是由new关键字申请出来的
		(4)绝大部分时候，程序使用new关键字为一个Java对象申请空间之后，都需要使用构造器为这个对象执行初始化
		(5)但在某些时候，程序创建Java对象无须调用构造器，以下面两种方式创建的Java对象无须使用构造器
			a.使用反序列化的方式恢复Java对象
			b.使用clone方法复制Java对象
	3)可能读者对自己以前写的某些单例类感到害怕，以前那些通过把构造器私有来保证只产生一个实例的类真的不会产生多个实例吗?
		如果程序使用反序列化机制不是可以获取多个实例吗?没错，程序完全通过这种反序列化机制会确实会破坏单例类的规则，
		当然，大部分时候也不会主动使用反序列机制去破坏单例类的规则，如果真的想保证反序列时也不会产生多个Java实例，
		则应该为单例类提供readResolve()方法，该方法保证反序列化时得到已有的Java实例
	4)除了可以使用反序列化机制恢复Java对象无须构造器之外，使用clone()方法复制Java对象也无须调用构造器，
		如果希望某个Java类的实例是可复制的，则对该Java类有如下两个要求
		(1)让该Java类实现Cloneable接口
		(2)为该Java类提供clone()方法，该方法负责进行复制
		(3)通过clone()方法来复制自己
			Dog dog=null
			dog=(Dog)super.clone()
			return dog
	5)无限递归的构造器
		(1)不要忘记了，不管是定义实例变量时指定的初始化值，还是在非静态初始化块中执行的初始化操作
			最终都将被提取到构造器中执行
		(2)代码递归调用了类的构造器，所以实际运行该程序将导致出现java.lang.StackOverflowError异常
		(3)这个程序给出的教训是，无论如何不要导致构造器产生递归调用，也就是说，应该
			a.尽量不要在定义实例变量时指定实例变量的值为当前类的实例
			b.尽量不要在初始化块中创建当前类的实例
			c.尽量不要在构造器内调用本构造器创建Java对象
3.持有当前类的实例
	1)前面程序已经指出，定义实例变量时指定实例变量的值为当前类的实例很容易导致构造器递归调用
	2)也就是说，当某个类的对象持有当前类的实例时，某个实例递归地引用当前类的实例很容易导致构造器递归调用
	3)不过，在一些特定的情况下，程序必须让某个类的一个实例持有当前类的另一个实例，
		例如链表，每个节点都持有一个引用，该引用指向下一个链表节点
	4)对于一个Java类而言，它的一个实例变量持有当前类的另一个实例是被允许的，
		只要程序初始化它所持有的当前类的实例时不会引用构造器递归就行
4.到底调用哪个重载的方法
	1)Java的重载解析过程分成以下两个阶段
		(1)第一阶段jvm将会选取所有可获得并匹配调用的方法或构造器，在这个阶段里会把调用数字方法如double int都选取出来
		(2)第二阶段决定到底要调用哪个方法，此时jvm会在第一阶段所选取的方法或构造器中再次选取更精确匹配的那一个
	2)当出现(Object obj)和(Object[] objs)时，调用传入null时
		(1根据精确匹配的原则，当实际调用时传入的实参同时满足多个方法时，
			如果某个方法的形参要求参数范围越小，那么这个方法就越精确
		(2)很明显,Object[]可看成Object的子类，(Object[])方法匹配得更精确，执行上面的程序，将看到如下输出
			objs的参数为null
	3)当出现极端复杂的情况下，jvm无法断定哪个方法更匹配实际调用，程序将会导致编译错误	