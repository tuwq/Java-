第十一章 树和二叉树
1.转换方法
	1)由于二叉树是一种更确定(它的每个节点最多只有两个子节点)的数据结构，因此不管存储、增加、删除节点，还是遍历节点，程序都可以更简单、方便地实现
		反之，由于树的每个节点具有个数不确定的子节点，因此程序实现起来更复杂。
	2)为了充分利用二叉树的简单易用性，可以将普通树转换为二叉树，以二叉树的形式来保存普通树，当程序需要树时，再将二叉树转换为普通树
	3)森林其实更简单，如果将一棵普通树的根节点去掉，这棵树就变成了森林，或者可以转换一下思维，森林其实就是有多个根节点的树
2.森林、树和二叉树的转换
	1)有序树、森林和二叉树之间有--映射的关系，可以进行相互转换
		多叉树向二叉树转换的方法如下
		(1)加虚线:同一个父节点的相邻兄弟节点之间加虚线
		(2)抹实线:每个节点只保留它与最左子节点的连线，与其他子节点的连线都被抹掉
		(3)虚改实:虚线改实线
		从这个转换结果来看，多叉树转换为二叉树的方法的关键思路就是:所有子节点只保留子节点，其他子节点转为左子节点的右子节点链
	2)按照这种转换思路，森林也可以转换为二叉树--只要把森林当成一棵根节点被删除的多叉树即可
	3)反过来，二叉树也可恢复出对应的多叉树、森林，恢复方法如下
		(1)加虚线:若某节点I是父节点的左子节点，则为该节点I的右孩子链的所有节点分别与节点I的父节点连线
		(2)抹线:把有虚线的节点与原父节点的连线抹去
		(3)整理:虚改实并按层排列
		如果二叉树的根节点有右子节点--右子节点就代表根节点的兄弟节点，这种情况会被转换得到森林
	4)如果二叉树的根节点的右子节点链只有一个节点，那么转换出来的森林将有两棵树，如果二叉树的根节点的右子节点链有N个节点，
		那么转换出来的森林将有N+1(根节点本身)棵树
	5)树的链表存储
		(1)根据上面介绍的理论，二叉树可以和多叉树之间进行自由转换，因此可以得到普通树的另一种保存方式
		(2)以二叉树的形式保存多叉树，实际需要的时候再将二叉树再转换为普通树
		(3)至于到底以哪种方式来保存二叉树，完全是自由的，通常会选择使用三叉链表存储方式来保存二叉树，
			这样得到的二叉树操作起来更方便，进行二叉树和多叉树之间的转换时也更方便
3.哈夫曼树
	1)哈夫曼树又被称为最优二叉树，是一种带权路径最短的二叉树，哈夫曼树是二叉树的一种应用，在信息检索中很常用
	2)哈夫曼树的定义和基本概念
		(1)在介绍哈夫曼树之前来介绍一些相关的概念
			a.节点之间的路径长度，从一个节点到另一个节点之间的分支数量称为两个节点之间的路径长度
			b.树的路径长度:从根节点到树中每一个路径的路径长度之和
			c.节点的带权路径长度:从该节点到根节点之间的路径长度与节点的权的乘积
			c.树的带权路径长度:树中所有叶子节点的带权路径长度之和
		(2)带权路径最小的二叉树被称为哈夫曼树或最优二叉树
		(3)对于哈夫曼树，有一个很重要的定理，对于具有n个叶子节点的哈夫曼树，一共需要2*n-1个节点，因为对于二叉树来说，有三种类型节点
			a.度数为2的节点，度数为1的节点、度数为0的节点
		(4)哈夫曼树的非叶子节点都是由两个节点合并产生的，所以不会出现度数为1的节点，而生成的非叶子节点的个数为叶子节点数-1
		(5)因此n个叶子节点的哈夫曼树，一共需要2*n-1个节点
	3)创建哈夫曼树，可以按如下步骤进行
		(1)根据给定的n个权值(w1,w2,..,wn)构造n棵二叉树的集合F={T1,T2,..,Tn}，F集合中每个二叉树都只有一个根节点
		(2)选取F集合中两棵根节点的权值最小的树作为左、右子树以构造一棵新的二叉树，且将新的二叉树的根节点的权值设为左、右子树上根节点的权值之和
		(3)将新的二叉树加入到F集合中，并删除第二步中被选中的两棵树
		(4)重复第2和第3步，直到F集合中只剩下一棵树，这棵树就是哈夫曼树
	4)参见HuffmanTree实现
	5)创建哈夫曼树的关键代码就是粗体字代码(createTree方法中),完成了以下事情
		(1)对List集合中的所有节点进行排序
		(2)找到List集合中权值最小的两个节点
		(3)以权值最小的两个节点作为子节点创建新节点
		(4)从List集合中删除权值最小的两个节点，将新节点添加到List集合中
		程序采用循环不断地执行上面的第1~4步，直到List集合中只剩一个节点，最后剩下的这个节点就是哈夫曼树的根节点
4.哈夫曼编码
	1)根据哈夫曼树可以解决报文编码问题，假设需要对一个字符串如"abcdabcab"进行编码，将它转换为唯一的二进制码，但要求转换出来的二进制的长度最小
	2)假设每个字符在字符串中出现的频率为W，其编码长度为L，编码字符有n个，则编码后二进制的总长度为W1L1+W2L2+W3L3+..+WnLn,这正好符合哈夫曼树的处理原则
	3)因此可采用哈夫曼树的原理构造二进制码，并使电文总长最短
	4)对于"abcdabcab"字符串，总共只有a,b,c,d四个字符，它们出现的次数分别是4，3，2，1次，这相当于它们的权值，
		于是，将a,b,c,d四个字符以出现的次数为权值构造哈夫曼树
	5)从哈夫曼树根节点开始，，对左子树分配代码0，对右子树分配代码1，一直到达叶子节点，
		然后，将从树根沿每条路径到达叶子节点的代码排列起来，使得到了每个叶子节点的哈夫曼编码
	6)a和哈夫曼编码为0，b的哈夫曼编码为10，c的哈夫曼编码为110，d的哈夫曼编码为111，然后将"abcdabcab“这个字符串转换为对应的二进制码0101101110101100100.长度仅为19
	7)这就是该字符串的最短二进制编码，也被成为哈夫曼编码
	8)哈夫曼编码有一个规律，假设有N个叶子节点需要编码，最终得到的哈夫曼树一定有N层，哈夫曼编码得到的二进制码的最大长度为N-1
	9)程序将N个叶子节点按权值由小到大排列，这些叶子节点对应的哈夫曼编码依次为0、10、110、1110、11110(一共有N-1位)
5.排序二叉树
	1)排序二叉树是一种特殊结构的二叉树，通过它可以非常方便地对树中的所有节点进行排序和检索
	2)排序二叉树要么是一棵空树，要么具有下列性质的二叉树
		(1)若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值
		(2)若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值
		(3)它的左、右子树也分别为排序二叉树
	4)对于排序二叉树，若按中序遍历就可以得到由小到大的有序序列 (2,3,4,8,9,9,10,10,15)
	5)创建排序二叉树的步骤，就是不断地向排序二叉树添加节点的过程，具体如下
		(1)以根节点为当前节点开始搜索
		(2)拿新节点的值和当前节点的值比较
		(3)如果新节点的值更大，则以当前节点的右子节点作为新的当前节点，如果新节点的值更小，则以当前节点的左子节点作为新的当前节点
		(4)重复第2和3两个步骤，直到搜索到合适的叶子节点
		(5)将新节点添加为第4步找到的叶子节点的子节点，如果新节点的值更大，则添加为右子节点，否则，添加为左子节点
	6)当程序从排序二叉树中删除一个节点之后，为了让它依然保持为排序二叉树，必须对该排序二叉树进行维护，维护可分为如下几种情况、
		(1)被删除节点是叶子节点，只需将它从其父节点中删除
		(2)被删除节点p只有左子树或右子树，
			a.如果p是它的父节点的左子节点，则将P的左子树或右子树添加成p节点的父节点的左子节点即可；
			b.如果p是它的父节点的右子节点，则将p的左子树或右子树添加成p节点的父节点的右子节点即可
			简单来说，如果要删除的节点只有一个节点，即可用它的子节点来代替要删除的节点 
		(3)若被删除节点p的左、右子树均非空，则有以下两种做法
			a.将pL设为p的父节点q的左或右子节点(取决于p是其父节点q的左、右节点)，
			  将pR设为p节点的中序前趋节点s的的右子节点(s是pL最右下的节点,也就是pL子树中的最大节点)
				(将p左子节点设为q的子节点，将p的右子节点设置pL子树中最大节点的右子)
			b.以p节点的中序前趋或后继替代p所指节点，然后从原排序二叉树中删除中序前趋或后继节点
			简单来说，就是用大于p的最小节点或小于p的最大节点代替p节点
	7)参见SortedBinTree<T extends Comparable>实现		