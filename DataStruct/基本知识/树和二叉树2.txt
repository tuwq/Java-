第十一章 树和二叉树
1.转换方法
	1)由于二叉树是一种更确定(它的每个节点最多只有两个子节点)的数据结构，因此不管存储、增加、删除节点，还是遍历节点，程序都可以更简单、方便地实现
		反之，由于树的每个节点具有个数不确定的子节点，因此程序实现起来更复杂。
	2)为了充分利用二叉树的简单易用性，可以将普通树转换为二叉树，以二叉树的形式来保存普通树，当程序需要树时，再将二叉树转换为普通树
	3)森林其实更简单，如果将一棵普通树的根节点去掉，这棵树就变成了森林，或者可以转换一下思维，森林其实就是有多个根节点的树
2.森林、树和二叉树的转换
	1)有序树、森林和二叉树之间有--映射的关系，可以进行相互转换
		多叉树向二叉树转换的方法如下
		(1)加虚线:同一个父节点的相邻兄弟节点之间加虚线
		(2)抹实线:每个节点只保留它与最左子节点的连线，与其他子节点的连线都被抹掉
		(3)虚改实:虚线改实线
		从这个转换结果来看，多叉树转换为二叉树的方法的关键思路就是:所有子节点只保留子节点，其他子节点转为左子节点的右子节点链
	2)按照这种转换思路，森林也可以转换为二叉树--只要把森林当成一棵根节点被删除的多叉树即可
	3)反过来，二叉树也可恢复出对应的多叉树、森林，恢复方法如下
		(1)加虚线:若某节点I是父节点的左子节点，则为该节点I的右孩子链的所有节点分别与节点I的父节点连线
		(2)抹线:把有虚线的节点与原父节点的连线抹去
		(3)整理:虚改实并按层排列
		如果二叉树的根节点有右子节点--右子节点就代表根节点的兄弟节点，这种情况会被转换得到森林
	4)如果二叉树的根节点的右子节点链只有一个节点，那么转换出来的森林将有两棵树，如果二叉树的根节点的右子节点链有N个节点，
		那么转换出来的森林将有N+1(根节点本身)棵树
	5)树的链表存储
		(1)根据上面介绍的理论，二叉树可以和多叉树之间进行自由转换，因此可以得到普通树的另一种保存方式
		(2)以二叉树的形式保存多叉树，实际需要的时候再将二叉树再转换为普通树
		(3)至于到底以哪种方式来保存二叉树，完全是自由的，通常会选择使用三叉链表存储方式来保存二叉树，
			这样得到的二叉树操作起来更方便，进行二叉树和多叉树之间的转换时也更方便
3.哈夫曼树
	1)哈夫曼树又被称为最优二叉树，是一种带权路径最短的二叉树，哈夫曼树是二叉树的一种应用，在信息检索中很常用
	2)哈夫曼树的定义和基本概念
		(1)在介绍哈夫曼树之前来介绍一些相关的概念
			a.节点之间的路径长度，从一个节点到另一个节点之间的分支数量称为两个节点之间的路径长度
			b.树的路径长度:从根节点到树中每一个路径的路径长度之和
			c.节点的带权路径长度:从该节点到根节点之间的路径长度与节点的权的乘积
			c.树的带权路径长度:树中所有叶子节点的带权路径长度之和
		(2)带权路径最小的二叉树被称为哈夫曼树或最优二叉树
		(3)对于哈夫曼树，有一个很重要的定理，对于具有n个叶子节点的哈夫曼树，一共需要2*n-1个节点，因为对于二叉树来说，有三种类型节点
			a.度数为2的节点，度数为1的节点、度数为0的节点
		(4)哈夫曼树的非叶子节点都是由两个节点合并产生的，所以不会出现度数为1的节点，而生成的非叶子节点的个数为叶子节点数-1
		(5)因此n个叶子节点的哈夫曼树，一共需要2*n-1个节点
	3)创建哈夫曼树，可以按如下步骤进行
		(1)根据给定的n个权值(w1,w2,..,wn)构造n棵二叉树的集合F={T1,T2,..,Tn}，F集合中每个二叉树都只有一个根节点
		(2)选取F集合中两棵根节点的权值最小的树作为左、右子树以构造一棵新的二叉树，且将新的二叉树的根节点的权值设为左、右子树上根节点的权值之和
		(3)将新的二叉树加入到F集合中，并删除第二步中被选中的两棵树
		(4)重复第2和第3步，直到F集合中只剩下一棵树，这棵树就是哈夫曼树
	4)参见HuffmanTree实现
	5)创建哈夫曼树的关键代码就是粗体字代码(createTree方法中),完成了以下事情
		(1)对List集合中的所有节点进行排序
		(2)找到List集合中权值最小的两个节点
		(3)以权值最小的两个节点作为子节点创建新节点
		(4)从List集合中删除权值最小的两个节点，将新节点添加到List集合中
		程序采用循环不断地执行上面的第1~4步，直到List集合中只剩一个节点，最后剩下的这个节点就是哈夫曼树的根节点
4.哈夫曼编码
	1)根据哈夫曼树可以解决报文编码问题，假设需要对一个字符串如"abcdabcab"进行编码，将它转换为唯一的二进制码，但要求转换出来的二进制的长度最小
	2)假设每个字符在字符串中出现的频率为W，其编码长度为L，编码字符有n个，则编码后二进制的总长度为W1L1+W2L2+W3L3+..+WnLn,这正好符合哈夫曼树的处理原则
	3)因此可采用哈夫曼树的原理构造二进制码，并使电文总长最短
	4)对于"abcdabcab"字符串，总共只有a,b,c,d四个字符，它们出现的次数分别是4，3，2，1次，这相当于它们的权值，
		于是，将a,b,c,d四个字符以出现的次数为权值构造哈夫曼树
	5)从哈夫曼树根节点开始，，对左子树分配代码0，对右子树分配代码1，一直到达叶子节点，
		然后，将从树根沿每条路径到达叶子节点的代码排列起来，使得到了每个叶子节点的哈夫曼编码
	6)a和哈夫曼编码为0，b的哈夫曼编码为10，c的哈夫曼编码为110，d的哈夫曼编码为111，然后将"abcdabcab“这个字符串转换为对应的二进制码0101101110101100100.长度仅为19
	7)这就是该字符串的最短二进制编码，也被成为哈夫曼编码
	8)哈夫曼编码有一个规律，假设有N个叶子节点需要编码，最终得到的哈夫曼树一定有N层，哈夫曼编码得到的二进制码的最大长度为N-1
	9)程序将N个叶子节点按权值由小到大排列，这些叶子节点对应的哈夫曼编码依次为0、10、110、1110、11110(一共有N-1位)
5.排序二叉树
	1)排序二叉树是一种特殊结构的二叉树，通过它可以非常方便地对树中的所有节点进行排序和检索
	2)排序二叉树要么是一棵空树，要么具有下列性质的二叉树
		(1)若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值
		(2)若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值
		(3)它的左、右子树也分别为排序二叉树
	4)对于排序二叉树，若按中序遍历就可以得到由小到大的有序序列 (2,3,4,8,9,9,10,10,15)
	5)创建排序二叉树的步骤，就是不断地向排序二叉树添加节点的过程，具体如下
		(1)以根节点为当前节点开始搜索
		(2)拿新节点的值和当前节点的值比较
		(3)如果新节点的值更大，则以当前节点的右子节点作为新的当前节点，如果新节点的值更小，则以当前节点的左子节点作为新的当前节点
		(4)重复第2和3两个步骤，直到搜索到合适的叶子节点
		(5)将新节点添加为第4步找到的叶子节点的子节点，如果新节点的值更大，则添加为右子节点，否则，添加为左子节点
	6)当程序从排序二叉树中删除一个节点之后，为了让它依然保持为排序二叉树，必须对该排序二叉树进行维护，维护可分为如下几种情况、
		(1)被删除节点是叶子节点，只需将它从其父节点中删除
		(2)被删除节点p只有左子树或右子树，
			a.如果p是它的父节点的左子节点，则将P的左子树或右子树添加成p节点的父节点的左子节点即可；
			b.如果p是它的父节点的右子节点，则将p的左子树或右子树添加成p节点的父节点的右子节点即可
			简单来说，如果要删除的节点只有一个节点，即可用它的子节点来代替要删除的节点 
		(3)若被删除节点p的左、右子树均非空，则有以下两种做法
			a.将pL设为p的父节点q的左或右子节点(取决于p是其父节点q的左、右节点)，
			  将pR设为p节点的中序前趋节点s的的右子节点(s是pL最右下的节点,也就是pL子树中的最大节点)
				(将p左子节点设为q的子节点，将p的右子节点设置pL子树中最大节点的右子)
			b.以p节点的中序前趋或后继替代p所指节点，然后从原排序二叉树中删除中序前趋或后继节点
			简单来说，就是用大于p的最小节点或小于p的最大节点代替p节点
	7)参见SortedBinTree<T extends Comparable>实现	
6.红黑树
	1)排序二叉树虽然可以快速检索，但在最坏的情况下，如果插入的节点集本身就是有序的，要么是由小到大排列，要么是由大到小排序，那么最后得到的排序二叉树将变成链表
	2)所有节点只有左子节点(如果插入节点集合本身是由大到小排列的)，或者所有节点只有右子节点(如果插入节点集合本身是由小到大排列的)
	3)在这种情况下，排序二叉树就会变成普通链表，其搜索效率就会很低
	4)红黑树是一个更高效的检索二叉树，又名"对称二叉树B树"，因此常常用来实现关联数组，，典型的，JDK提供的集合类TreeMap本身就是一棵红黑树的实现
	5)红黑树在原有的排序二叉树增加了如下几个要求
		(1)性质1:每个节点要么是红色，要么是黑色
		(2)性质2:根节点永远是黑色的
		(3)性质3所有的叶子节点都是空节点(即是null)，并且是黑色的
		(4)性质4:每个红色节点的两个子节点都是黑色，(从每个叶子到根的路径上不会出现有两个连续的红色节点)
		(5)性质5:从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点
	5)根据性质5，红黑树从根节点到每个叶子节点的路径都包含相同数量的黑色节点，因此从根节点到叶子节点的路径中包含的黑色节点数被称为树的黑色高度
	6)根据性质4，保证了从根节点到叶子节点的最长路径的长度不会超过任何其他路径的两倍
	7)如有一棵黑色高度为3的红黑树，从根节点到叶子节点的最短路径长度是2，该路径上全是黑色节点(黑色-黑色-黑色)，最长路径也只可能为4，
		在每个黑色节点之间插入一个红色节点(黑色-红色-黑色-红色-黑色)，性质4保证绝不可能插入更多的红色节点，由此可见，红黑树中最长的路径就是一条红黑交替的路径
	8)对于给定的黑色高度为N的红黑树，从根到叶子节点的最短路径长度为N-1，最长路径长度为2*(N-1)
	9)红黑树通过上面这种限制来保存它大致是平衡的--因为红黑树的高度不会无限增高，这样能保证红黑树在最坏的情况下都是高效的，不会出现普通排序二叉树的情况
	10)由于红黑树只是一棵特殊的排序二叉树，因此对红黑树上的只读操作与普通排序二叉树上的只读操作完全相同，只是红黑树保持大致平衡，因此检索性能更好
	11)但在红黑树上进行插入操作和删除操作会导致树不再符合红黑树的特征，因此插入操作和删除操作都需要一定的维护，以保证插入节点、删除节点后的树依然是红黑树
	12)插入操作按如下步骤进行
		(1)以排序二叉树的方法插入新节点，并将它设为红色 
			如果设为黑色，就会导致根节点到叶子节点的路径上多了一个额外的黑色节点，这样将会导致很难调整，
			但是设为红色节点后，可能会导致出现两个连续的红色节点，再通过颜色调整和树旋转即可
		(2)进行颜色调换和树旋转就比较复杂了，下面将分情况进行介绍了，在介绍中，把新插入的节点定义为N节点，把N节点的父节点定义为p节点，把p节点的兄弟节点定义为u节点，
			把p节点的父节点定义为g节点
	13)颜色调换和树旋转
		(1)情形1:新节点N是树的根节点，没有父节点
			在这种情形下，直接将它设置为黑色以满足性质2
		(2)情形2:新节点的父节点p是黑色的
			a.在这种情形下，新插入的节点是红色的，因此依然满足性质4，而且因为新节点N有两个黑色叶子节点
			b.由于新节点N是红色的，通过它的每个子节点的路径依然保持相同的黑色节点数，因此依然满足性质5
		(3)情形3:父节点p和父节点的兄弟节点u都是红色的
			a.在这种情形下，程序应该将p和u都设置为黑色，并将p节点的父节点设置为红色(用于保持性质5)，现在，新节点N有了一个黑色的父节点p
			b.由于从p和u到根节点的任何路径都必须通过g节点，这些路径上的黑色节点数目没有改变(原来有叶子和g两个黑色节点，现在有叶子和p两个黑色节点)
			经过上面的处理后，红色的g节点的父节点也有可能是红色的，这就违反了性质4，因此还需要对g节点递归地进行整个过程(把g节点当成新插入的节点进行处理)
		(4)情形4:父节点p是红色的，而其兄弟节点u是黑色或缺少，且新节点N是父节点p的的右子节点，而父节点p又是其父节点g的左子节点
			a.在这种情形下，对新节点和其父节点进行一次左旋转(右子为轴，当前节点为左旋)，接着，按情形5处理以前的父节点p(也就是把p当成新插入的节点)
			b.这将导致某些路径通过它们以前不通过的新节点N或父节点p其中之一，但这两个节点都是红色的，因此不会影响性质5
		(5)情形5:父节点p是红色的，而其兄弟节点u是黑色或缺少，且新节点N是父节点p的左子节点，而父节点p又是其父节点g的左子节点
			a.在这种情形下，需要对节点g进行一次右旋转(左子为轴，当前节点为右旋)，在旋转产生的树中，以前的父节点p现在是新节点n和节点g的父节点，
			b.由于以前的节点g是黑色的(否则父节点p就不可能是红色的),切换以前的父节点p和节点g的颜色，使之满足性质4
			c.性质5也仍然保持满足，因为通过这三个节点中任何一个的所有路径以前也通过节点g，现在它们都通过以前的父节点p,在各自情况下，p都是这三个节点中(g、p、n)唯一的黑色节点
	(14)参见RedBlackTree<T extends Comparable>实现	
