第十二章 常用的内部排序
1.排序算法的属于算法的一种，而且是覆盖范围极小的一种，虽然排序算法是计算机科学里的古老且研究人数相当多的一种算法，但千万不要把排序算法
	和广义的计算机算法等同起来，掌握排序算法对程序开发、程序思维的培养都有很大帮助，但掌握排序算法绝不等于掌握了计算机编程算法的全部
	广义的算法包含客观世界运行的规律
2.排序的基本概念
	(1)在计算机程序开发过程中，经常需要对一组数据元素(或记录)按某个关键字进行排序，排序完成的序列可用于快速查找相关记录
3.排序概述
	(1)排序是程序开发中一种非常常见的操作，对一组任意的数据元素(或记录)经过排序操作后，就可以把它们变成一组按关键字排序的有序序列
	(2)假设含有n个记录的序列为(R1,R2,..,Rn),其相应的关键字序列为(K1,K2,..,Kn),将这些记录重新排序为(Ri1,Ri2,..,Rin),
		使得相应的关键字值满足条件Ki1<=Ki2<=..<=Kin,这样的一种操作称为排序
	(3)一旦将一组杂乱无章的记录重排成一组有序记录，就能快速地从这组记录中找到目标记录，因此通常来说，排序的目的是快速查找
		a.时间复杂度:主要是分析关键字的比较次数和记录的移动次数
		b.空间复杂度:分析排序算法中需要多少辅助内存
		c.稳定性:若两个记录A和B的关键字值相等，但排序后A、B的先后次序保持不变，则称这种排序算法是稳定的，反之，就是不稳定的
	(4)就现有的排序算法来看，排序大致可分为内部排序和外部排序，
		a.如果整个排序过程不需要借助于外部的存储器(如磁盘等),所有排序操作都在内存中完成这种排序就被称为内部排序
		b.如果参与排序的数据元素非常多，数据量非常大，计算机无法整个排序过程放在内存中完成，必须借助于外部存储器(如磁盘)，这种排序就称为外部排序
	(5)外部排序最常用的算法是多路归并排序，即将原文件分解成多个能够一次性装入内存的部分，分别把每一部分调入内存完成排序，接下来再对多个有序的子文件进行归并排序
	(6)外部排序包括以下两个步骤
		a.把要排序的文件中一组记录读入内存的排序区，对读入的记录按上面讲到的内部排序法进行排序，排序之后输出到外部存储器。
			不断重复这一过程，每次读取一组记录，直到原文件的所有记录被处理完毕
		b.将上一步分组排序好的记录两组两组地合并排序，在内存容量允许的情况下，每组中包含的记录越大越好，这样可减少合并的次数
	(7)将上一步分组排序好的记录两组两组地合并排序，在内存容量允许的条件下，每组中包含的记录越大越好，这样可减少合并的次数
	(8)对于外部排序来说，程序必须将数据分批调入内存来排序，中间结果还要及时放入外存，显然外部排序比内部排序更复杂，实际上也可认为外部排序是由多次内部排序组成的
		常用的排序都是指内部排序，而不是外部排序
4.内部排序的分类
	(1)就内部排序来说，可以使用非常简单的排序算法来完成，如直接选择，直接插入等，但也有一些非常优秀、复杂排序算法，如快速排序、基数排序等
	(2)就常用的内部排序算法来说，可以分为如下几类
		a.选择排序
		b.交换排序
		c.插入排序
		d.归并排序
		e.桶式排序
		f.基数排序
5.选择排序法
	常用的选择排序方法有两种，直接选择排序和堆排序，直接选择排序简单直观，但性能略差；堆排序是一种较为高效得的选择排序方法，但实现起来略微复杂
	1)直接选择排序
		直接选择排序的思路很简单，它需要经过n-1趟比较
		(1)第1趟比较:程序将记录定位在第1个数据上，拿第1个数据依次和它后面的每个数据进行比较，如果第1个数据大于后面某个数据，就交换它们..
			依次类推，经过第1躺比较，这组数据中最小的数据被选出，它被排在第1位
		(2)第2趟比较:程序将记录定位在第2个数据上，拿第2个数据依次和它后面的每个数据进行比较，如果第2个数据大于后面某个数据，就交换它们..
			依次类推，经过第2躺比较，这组数据中第2小的数据被选出，它被排在第2位
		(3)按此规则一共进行n-1躺比较，这组数据中第n-1小(第2大)的数据被选出，被排在第n-1(倒数第一位)；剩下的就是最大的数据，它排在最后
		(4)直接选择排序的缺点是每躺只能确定一个元素，n个数据需要进行n-1趟比较
		(5)参见SelectSort实现
		(6)从上面的直接选择排序算法可以看出，直接选择排序算法的关键就是n-1趟比较，每趟比较的目的就是选择出本趟比较中最小的数据，并将该数据放在本趟比较的第1位，
			从这里的描述不难发现，其实直接选择排序的每趟比较最多只需交换一次就够，只要找到本趟比较中最小的数据，然后拿它和本趟比较中第1为的数据交换
		(7)在这种算法规则下，每趟比较的目的只是找出本趟比较中最小数据的索引，也就是上面程序中minIndex变量所保存的值，当本趟比较的第1位(由变量i保存)与minIndex不相等时
			交换i和minIdex两处的数据
		(8)直接选择排序的第n趟比较至多交换一次，永远总是拿n-1位的数据和中间某个数据(本趟比较中最小的数据)进行交换，
			如果本趟比较时第n-1位(本趟比较的第1位)的数据已经是最小了，那就无须交换
		对于直接选择排序算法而言，假设有n个数据，数据交换的次数最多有n-1次，但程序比较次数较多。总体来说，其时间效率O(n^2)
		直接选择排序算法的空间效率很高，它只需要一个附加程序单元用于交换，其空间效率为O(1)，从两个data为30的DataWrap的排序结果来看，直接选择排序是不稳定的
	2)堆排序
		在介绍堆排序之前，先来介绍一下与堆有关的概念
		(1)假设有n个数据元素的序列k0,k1,..,kn+1，当且仅当满足如下关系时，可以将这组数据称为小顶堆(小根堆)
			k1<=k2i+1且ki<=k2i+2(其中i=0,2,..,(n-1)/2)
			或者满足以下关系时，可以将这组数据称为大顶堆(大根堆)
			k1>=k2i+1且ki>=k2i+2(其中i=0,2,..,(n-1)/2)
			对于满足小顶堆的数据序列k0,k1,..kn-1，如果将它们顺序排成一棵完全二叉树，则此树的特点是，树中所有节点的值都小于其左、右子节点的值，此树的根节点的值必然最小
			反之，对于满足大顶堆的数据序列k0,k1,..kn-1,如果将它们的顺序排成一棵完全二叉树，则此树的特点是，树中所有节点的值都大于其左、右子节点的值，此树的根节点的值必然最大
		(2)通过上面的介绍不难发现一点，小顶堆的任意子树也是小顶堆，大顶堆的任意子树还是大顶堆
		(3)HeapSort实现
6.交换排序
	交换排序的主体操作是对数据组中的数据不断地进行交换操作，交换排序主要有冒泡排序和快速排序，这两种排序都是广为人知且应用极广的排序算法
	1)冒泡排序
		(1)冒泡排序是最广为人知的交换排序之一，具有算法思路简单、容易实现的特点
		对于包含n个数据的一组记录，在最坏的情况下，冒泡排序需要进行n-1躺比较
		第一趟:依次比较0和1、1和2、2和3、..n-2和n-1索引处的元素，如果发现第一个数据大于后一个数据，则交换它们，经过第1趟比较，最大的元素排到了最后
		第二趟:依次比较0和1、1和2、2和3、..n-3和n-2索引处的元素，如果发现第一个数据大于后一个数据，则交换它们，经过第2趟比较，第2大的元素排到了倒数第2位
		第n-1趟:依次比较0和1元素，如果发现第一个数据大于后一个数据，则交换它们，经过n-1趟比较，第2小(第n-1大)的元素排到了第2位
		实现上，冒泡排序的每趟交换结束后，不仅能将当前最大值挤出最后面位置，还能部分理顺前面的其他元素，一旦某趟没有交换发生，即可提前结束排序
		9,16,21*,23,30,49,21,30*
		只需要经过4趟比较
		第1趟:9,16,21,23,30,21,30,49
		第2趟:9,16,21,23,21,30,30,49
		第3趟:9,16,21,21,23,30,30,49
		第4趟:9,16,21,21,23,30,30,49
		从上面的排序过程可以看出，虽然该组数据包含8个元素，但采用冒泡排序只需要经过4趟比较，因为经过第3趟排序后，这组数据已经处于有序状态，这样，第4趟将不发生交换，提前结束
		BubbleSort实现
		冒泡排序算法的时间效率是不确定的，在最好的情况下，初始化数据序列已经处于有序状态，执行一趟冒泡即可，但在最坏的情况下，初始数据序列处于完全逆序状态，算法要执行
		n-1趟冒泡，第i趟(1<i<n)做n-i次比较，执行n-i-1次对象交换，此时的比较总次数为n*(n-1)/2,记录移动总次数为n*(n-1)3/2
		冒泡排序算法的空间效率很高，它只需要一个附加程序单元用于交换，其空间效率为O（1），冒泡排序是稳定的
	2)快速排序
		(1)快速排序是速度非常快交换排序方法，它的基本思路很简单，从待排序的数据序列中任取一个数据(如第一个数据)作为分界值，所有比它小的数据元素一律放在右边。
			经过这一趟下来，该序列形成左、右两个子序列，左边序列中数据元素的值都比分界值小、右边序列中的数据元素都比分界值大
		(2)接下来对左、右两个子序列进行递归，对两个子序列重新选择中心元素并依此规则调整，直到每个子序列的元素只剩一个，排序完成
			a.选出指定的分界值-这个很容易完成
			b.将所有比分界值小的数据元素放在左边
			c.将所有比分界值大的数据元素放在右边
		(3)现在的问题是，如何实现上面的第2和第3步?这时就要用到交换了，思路如下
			a.定义一个i变量，i变量从左边第一个索引开始，找大于分界值的元素的索引，并用i来记录它
			b.定义一个j变量，j变量从右边第一个索引开始，找小于分界值的元素的索引，并用j来记录它
			c。如果i<j,则交换i,j两个索引处的元素
			重复执行以上1~3步，直到i>=j,可以判断j左边的数据元素都小于分界值，j右边的数据元素都大于分界值，最后将分界值和j索引处的元素交换即可
			快速排序的速度确实很快，只要进过两次交换，即可让分界值左边的数据都小于分界值，分界值右边的数据都大于分界值
		(4)QuickSort实现
7.插入排序
	插入排序也是一类非常常见的排序方法，它主要包含直接插入排序、Shell排序和折半插入排序等几种常见的排序方法
	1)直接插入排序的思路非常简单:依次将待排序的数据元素按其关键字值的大小插入前面的有序序列
		细化来说，对于一个有n个元素的数据序列，排序需要进行n-1趟插入操作，如下所示
		(1)第1趟插入:将第2个元素插入前面的有序子序列中，此时前面只有一个元素，当然是有序的
		(2)第2趟插入:将第3个元素插入前面的有序子序列中，前面两个元素是有序的
		..
		(3)第n-1趟插入:将第n个元素插入前面的有序子序列中，前面n-1个元素是有序的
		(4)InsertSort实现
		(5)直接插入排序的时间效率并不高，在最坏的情况下，所有的元素的比较次数总和为(0+1+..+n-1)=O(n^2);在其他情况下，也要考虑移动元素的次数，固时间复杂度为O(n^2)
			直接插入排序的空间效率很好，它只需要一个缓存数据单元，也就是说，空间效率为O(1)，直接插入排序是稳定的
			