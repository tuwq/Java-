第十二章 常用的内部排序
总结:
	主要介绍了计算机内部排序的相关知识，首先，简要讲解了计算机排序算法的基本概念和作用，
	并简单说明了排序算法的分类。然后重点介绍了10种经典的内部排序算法
	直接选择排序、堆排序、冒泡排序、快速排序、直接插入排序、
	折半插入排序、shell排序、归并排序、桶式排序、基数排序
	学习这些排序算法时，应该先从逻辑上理解排序算法的理论，再结合书中的代码来掌握它们
1.排序算法的属于算法的一种，而且是覆盖范围极小的一种，虽然排序算法是计算机科学里的古老且研究人数相当多的一种算法，但千万不要把排序算法
	和广义的计算机算法等同起来，掌握排序算法对程序开发、程序思维的培养都有很大帮助，但掌握排序算法绝不等于掌握了计算机编程算法的全部
	广义的算法包含客观世界运行的规律
2.排序的基本概念
	(1)在计算机程序开发过程中，经常需要对一组数据元素(或记录)按某个关键字进行排序，排序完成的序列可用于快速查找相关记录
3.排序概述
	(1)排序是程序开发中一种非常常见的操作，对一组任意的数据元素(或记录)经过排序操作后，就可以把它们变成一组按关键字排序的有序序列
	(2)假设含有n个记录的序列为(R1,R2,..,Rn),其相应的关键字序列为(K1,K2,..,Kn),将这些记录重新排序为(Ri1,Ri2,..,Rin),
		使得相应的关键字值满足条件Ki1<=Ki2<=..<=Kin,这样的一种操作称为排序
	(3)一旦将一组杂乱无章的记录重排成一组有序记录，就能快速地从这组记录中找到目标记录，因此通常来说，排序的目的是快速查找
		a.时间复杂度:主要是分析关键字的比较次数和记录的移动次数
		b.空间复杂度:分析排序算法中需要多少辅助内存
		c.稳定性:若两个记录A和B的关键字值相等，但排序后A、B的先后次序保持不变，则称这种排序算法是稳定的，反之，就是不稳定的
	(4)就现有的排序算法来看，排序大致可分为内部排序和外部排序，
		a.如果整个排序过程不需要借助于外部的存储器(如磁盘等),所有排序操作都在内存中完成这种排序就被称为内部排序
		b.如果参与排序的数据元素非常多，数据量非常大，计算机无法整个排序过程放在内存中完成，必须借助于外部存储器(如磁盘)，这种排序就称为外部排序
	(5)外部排序最常用的算法是多路归并排序，即将原文件分解成多个能够一次性装入内存的部分，分别把每一部分调入内存完成排序，接下来再对多个有序的子文件进行归并排序
	(6)外部排序包括以下两个步骤
		a.把要排序的文件中一组记录读入内存的排序区，对读入的记录按上面讲到的内部排序法进行排序，排序之后输出到外部存储器。
			不断重复这一过程，每次读取一组记录，直到原文件的所有记录被处理完毕
		b.将上一步分组排序好的记录两组两组地合并排序，在内存容量允许的情况下，每组中包含的记录越大越好，这样可减少合并的次数
	(7)将上一步分组排序好的记录两组两组地合并排序，在内存容量允许的条件下，每组中包含的记录越大越好，这样可减少合并的次数
	(8)对于外部排序来说，程序必须将数据分批调入内存来排序，中间结果还要及时放入外存，显然外部排序比内部排序更复杂，实际上也可认为外部排序是由多次内部排序组成的
		常用的排序都是指内部排序，而不是外部排序
4.内部排序的分类
	(1)就内部排序来说，可以使用非常简单的排序算法来完成，如直接选择，直接插入等，但也有一些非常优秀、复杂排序算法，如快速排序、基数排序等
	(2)就常用的内部排序算法来说，可以分为如下几类
		a.选择排序
		b.交换排序
		c.插入排序
		d.归并排序
		e.桶式排序
		f.基数排序
5.选择排序法
	常用的选择排序方法有两种，直接选择排序和堆排序，直接选择排序简单直观，但性能略差；堆排序是一种较为高效得的选择排序方法，但实现起来略微复杂
	1)直接选择排序
		直接选择排序的思路很简单，它需要经过n-1趟比较
		(1)第1趟比较:程序将记录定位在第1个数据上，拿第1个数据依次和它后面的每个数据进行比较，如果第1个数据大于后面某个数据，就交换它们..
			依次类推，经过第1躺比较，这组数据中最小的数据被选出，它被排在第1位
		(2)第2趟比较:程序将记录定位在第2个数据上，拿第2个数据依次和它后面的每个数据进行比较，如果第2个数据大于后面某个数据，就交换它们..
			依次类推，经过第2躺比较，这组数据中第2小的数据被选出，它被排在第2位
		(3)按此规则一共进行n-1躺比较，这组数据中第n-1小(第2大)的数据被选出，被排在第n-1(倒数第一位)；剩下的就是最大的数据，它排在最后
		(4)直接选择排序的缺点是每躺只能确定一个元素，n个数据需要进行n-1趟比较
		(5)参见SelectSort实现
		(6)从上面的直接选择排序算法可以看出，直接选择排序算法的关键就是n-1趟比较，每趟比较的目的就是选择出本趟比较中最小的数据，并将该数据放在本趟比较的第1位，
			从这里的描述不难发现，其实直接选择排序的每趟比较最多只需交换一次就够，只要找到本趟比较中最小的数据，然后拿它和本趟比较中第1为的数据交换
		(7)在这种算法规则下，每趟比较的目的只是找出本趟比较中最小数据的索引，也就是上面程序中minIndex变量所保存的值，当本趟比较的第1位(由变量i保存)与minIndex不相等时
			交换i和minIdex两处的数据
		(8)直接选择排序的第n趟比较至多交换一次，永远总是拿n-1位的数据和中间某个数据(本趟比较中最小的数据)进行交换，
			如果本趟比较时第n-1位(本趟比较的第1位)的数据已经是最小了，那就无须交换
		对于直接选择排序算法而言，假设有n个数据，数据交换的次数最多有n-1次，但程序比较次数较多。总体来说，其时间效率O(n^2)
		直接选择排序算法的空间效率很高，它只需要一个附加程序单元用于交换，其空间效率为O(1)，从两个data为30的DataWrap的排序结果来看，直接选择排序是不稳定的
	2)堆排序
		在介绍堆排序之前，先来介绍一下与堆有关的概念
		(1)假设有n个数据元素的序列k0,k1,..,kn+1，当且仅当满足如下关系时，可以将这组数据称为小顶堆(小根堆)
			k1<=k2i+1且ki<=k2i+2(其中i=0,2,..,(n-1)/2)
			或者满足以下关系时，可以将这组数据称为大顶堆(大根堆)
			k1>=k2i+1且ki>=k2i+2(其中i=0,2,..,(n-1)/2)
			对于满足小顶堆的数据序列k0,k1,..kn-1，如果将它们顺序排成一棵完全二叉树，则此树的特点是，树中所有节点的值都小于其左、右子节点的值，此树的根节点的值必然最小
			反之，对于满足大顶堆的数据序列k0,k1,..kn-1,如果将它们的顺序排成一棵完全二叉树，则此树的特点是，树中所有节点的值都大于其左、右子节点的值，此树的根节点的值必然最大
		(2)通过上面的介绍不难发现一点，小顶堆的任意子树也是小顶堆，大顶堆的任意子树还是大顶堆
		(3)HeapSort实现
6.交换排序
	交换排序的主体操作是对数据组中的数据不断地进行交换操作，交换排序主要有冒泡排序和快速排序，这两种排序都是广为人知且应用极广的排序算法
	1)冒泡排序
		(1)冒泡排序是最广为人知的交换排序之一，具有算法思路简单、容易实现的特点
		对于包含n个数据的一组记录，在最坏的情况下，冒泡排序需要进行n-1躺比较
		第一趟:依次比较0和1、1和2、2和3、..n-2和n-1索引处的元素，如果发现第一个数据大于后一个数据，则交换它们，经过第1趟比较，最大的元素排到了最后
		第二趟:依次比较0和1、1和2、2和3、..n-3和n-2索引处的元素，如果发现第一个数据大于后一个数据，则交换它们，经过第2趟比较，第2大的元素排到了倒数第2位
		第n-1趟:依次比较0和1元素，如果发现第一个数据大于后一个数据，则交换它们，经过n-1趟比较，第2小(第n-1大)的元素排到了第2位
		实现上，冒泡排序的每趟交换结束后，不仅能将当前最大值挤出最后面位置，还能部分理顺前面的其他元素，一旦某趟没有交换发生，即可提前结束排序
		9,16,21*,23,30,49,21,30*
		只需要经过4趟比较
		第1趟:9,16,21,23,30,21,30,49
		第2趟:9,16,21,23,21,30,30,49
		第3趟:9,16,21,21,23,30,30,49
		第4趟:9,16,21,21,23,30,30,49
		从上面的排序过程可以看出，虽然该组数据包含8个元素，但采用冒泡排序只需要经过4趟比较，因为经过第3趟排序后，这组数据已经处于有序状态，这样，第4趟将不发生交换，提前结束
		BubbleSort实现
		冒泡排序算法的时间效率是不确定的，在最好的情况下，初始化数据序列已经处于有序状态，执行一趟冒泡即可，但在最坏的情况下，初始数据序列处于完全逆序状态，算法要执行
		n-1趟冒泡，第i趟(1<i<n)做n-i次比较，执行n-i-1次对象交换，此时的比较总次数为n*(n-1)/2,记录移动总次数为n*(n-1)3/2
		冒泡排序算法的空间效率很高，它只需要一个附加程序单元用于交换，其空间效率为O（1），冒泡排序是稳定的
	2)快速排序
		(1)快速排序是速度非常快交换排序方法，它的基本思路很简单，从待排序的数据序列中任取一个数据(如第一个数据)作为分界值，所有比它小的数据元素一律放在右边。
			经过这一趟下来，该序列形成左、右两个子序列，左边序列中数据元素的值都比分界值小、右边序列中的数据元素都比分界值大
		(2)接下来对左、右两个子序列进行递归，对两个子序列重新选择中心元素并依此规则调整，直到每个子序列的元素只剩一个，排序完成
			a.选出指定的分界值-这个很容易完成
			b.将所有比分界值小的数据元素放在左边
			c.将所有比分界值大的数据元素放在右边
		(3)现在的问题是，如何实现上面的第2和第3步?这时就要用到交换了，思路如下
			a.定义一个i变量，i变量从左边第一个索引开始，找大于分界值的元素的索引，并用i来记录它
			b.定义一个j变量，j变量从右边第一个索引开始，找小于分界值的元素的索引，并用j来记录它
			c。如果i<j,则交换i,j两个索引处的元素
			重复执行以上1~3步，直到i>=j,可以判断j左边的数据元素都小于分界值，j右边的数据元素都大于分界值，最后将分界值和j索引处的元素交换即可
			快速排序的速度确实很快，只要进过两次交换，即可让分界值左边的数据都小于分界值，分界值右边的数据都大于分界值
		(4)QuickSort实现
7.插入排序
	插入排序也是一类非常常见的排序方法，它主要包含直接插入排序、Shell排序和折半插入排序等几种常见的排序方法
	1)直接插入排序的思路非常简单:依次将待排序的数据元素按其关键字值的大小插入前面的有序序列
		细化来说，对于一个有n个元素的数据序列，排序需要进行n-1趟插入操作，如下所示
		(1)第1趟插入:将第2个元素插入前面的有序子序列中，此时前面只有一个元素，当然是有序的
		(2)第2趟插入:将第3个元素插入前面的有序子序列中，前面两个元素是有序的
		..
		(3)第n-1趟插入:将第n个元素插入前面的有序子序列中，前面n-1个元素是有序的
		(4)InsertSort实现
		(5)直接插入排序的时间效率并不高，在最坏的情况下，所有的元素的比较次数总和为(0+1+..+n-1)=O(n^2);在其他情况下，也要考虑移动元素的次数，固时间复杂度为O(n^2)
			直接插入排序的空间效率很好，它只需要一个缓存数据单元，也就是说，空间效率为O(1)，直接插入排序是稳定的
8.折半插入排序
	1)折半插入排序是对直接插入排序的简单改进，对于直接插入排序而言。当第i-1趟需要将第i元素插入前面的0~i~1个元素序列中时，它总是从i-1开始，逐个比较每个元素，
		直到找到它的位置，这显然没有利用前面0~i-1个元素已经有序这个特点，而折半插入排序则改进了一这点
		(1)对于折半插入排序而言，当第i-1趟需要将第i个元素插入前面的0~i-1个元素序列中时，它不会直接从i-1元素开始逐个比较元素，折半排序插入排序的做法如下
			a.计算0~i-1索引的中间点，也就是用i索引处的元素和(0+i-1)/2索引处的元素进行比较，如果i索引处的元素大，就直接在(0+i-1)/~i-1半个范围内搜索，反之，
				就在0~(0+i-1)/2半个范围内搜索，这就是所谓的折半
			b.在半个范围内搜索时，再按第1步方法进行折半搜索，总是不断地折半，这样就可以将搜索范围缩小到1/2、1/4、1/8,从而快速确定第i个元素的插入位置
			c。一旦确定了第i个元素的插入位置，剩下的事情就简单了，程序将该位置以后的元素整体后移一位，然后将第i个元素放入该位置
		(2)BinaryInsertSort实现
		(3)程序会拿tmp的值和mid索引(就是中间索引)处的值进行比较，如果tmp大于mid索引处的元素，则将low(搜素范围的下限)设置为mid+1
			即表明在mid+1到原high范围内搜索，反之，将high(搜索范围的上限)设置为mid-1，则表明在原low至min-1范围内搜索，折半插入排序可以更快确定第i个元素的位置
9.shell排序
	1)shell排序由Donald shell于1959年发现该排序算法是以其名字命名
	2)对于直接插入排序而言，当插入排序执行到一半时，待插值左边的所有数据都已经处于有序状态，直接插入排序将待插值存储在一个临时变量里，
		然后，从待插值左边的第一个数据单元开始，只要该数据单元的值大于待插值，该数据单元就右移一格，直到找到第一个小于待插值的数据单元，接下来
		将临时变量里的放入小于待插值的数据单元之后(前面的所有数据都右移过一格，因此该数据单元有一个空格)
	3）从上面算法可以发现一个问题:如果一个很小的数据单元位于很靠近右端的位置上，为了把这数据单元移动到左边正确的位置上，中间所有的数据单元都需要向右移动一格
		这个步骤对每一个数据项都执行了近n次的复制，虽然不是所有数据项都必须移动n个位置，但平均下来，每个数据项都会移动n/2格，总共是n^2/2次复制
		因此，插入排序的执行效率是O(n^2)
	4)shell排序对直接插入排序进行了简单的改进:它通过加大插入排序中元素之间的间隔，并在这些有间隔的元素中进行插入排序，从而使数据项大跨度地移动，
		当这些数据项排过一趟序后，shell排序算法减少数据项的间隔再进行排序，依次进行下去，这些进行排序的数据项之间的间隔被称为增量，习惯上用h来表示这个增量
	5)下面以如下数据序列为例
		9,-16,21*,23,-30,-49,21,30*,30
		如果采用直接插入排序算法:第i趟插入会将第i+1个元素插入前面的有序序列中，将看到:
		-16,9,21*,23,-30,-49,21,30*,30	-第一趟，将第2个元素插入，前面两个元素有序
		-16,9,21*,23,-30,-49,21,30*,30	-第二趟，将第3个元素插入，前面三个元素有序
		...
		shell排序就不这样了，假设本次shell排序的h为4，其插入操作如下_
		-30!	-16		21		23		9!		-49		21	30*		30!
		-30		-49!	21		23		9		-16!	21	30		30
		-30		-49		21!		23		9		-16		21! 30		30
		-30		-49		21		23!		9		-16		21	30!		30
		-30		-49		21		23		9!		-16		21	30		30!
		注意上面排序过程中的感叹号数据
		当h增量为4时，第1趟将保证索引为0、4、8的数据元素已经有序
		第一趟完成后，算法向右移一步，对索引为1、5的数据元素进行排序，这个排序过程是持续进行，直到所有的数据项都已经完成了以4为增量的排序
		所有间隔为4的数据项之间都已经排序有序
		当完成以4为增量的shell排序后，所有元素离它在最终有序序列中的位置相差不到两个单元，这就是数组的基本有序含义，也正是shell排序的奥秘所在
		通过创建这种交错的内部有序的数据项集合，就可以减少直接插入排序中数据项整体搬家的工作量
		上面已经演示了以4为增量的shell排序，接下来应该减少增量，直到完成以1为增量的shell排序，此时数据序列将会变为有序序列
	6)可以认为直接插入排序是shell排序的一种特例，直接使用增量为1的shell排序就是直接插入排序
	7)最终确定shell排序算法的关键就在于确定h序列的值，常用的h序列由Knuth提出，该序列从1开始，通过如下公式产生
		h=3*h+1
		上面公式用于从1开始计算这个序列，可以看到h序列为1,4,13,40...反过来，程序中还需要反向计算h序列，那应该使用如下公式
		h=(h-1)/3
		上面公式从最大的h计算，假设h从40开始，可以看到h序列为40,13,4,1
	8)shell排序比插入排序快很多，因为当h值大的时候，数据项每一趟排序需要移动元素的个数很少，但数据项移动的距离很长，这时非常有效率的
		当h减少时，每一趟排序需要移动的元素个数增多，但此时的数据项已经接近于它们排序后的最终的位置，这对于插入排序可以更有效率
		正是这两种情况的结合才使用shell排序效率更高
	9)ShellSort实现
9.归并排序
	1)归并的基本思想是将两个(或以上)有序的序列合并成一个新的有序序列，当然，此处介绍的归并排序主要是将两个有序的数据序列合并成一个新的有序序列
	2)细化来说，归并排序先将长度为n的无序序列看成是n个长度为1的有序子序列，首先做两两合并，得到n/2个长度为2的有序子序列，在做两两合并..
		不断重复这个过程，最终可以得到一个长度为n的有序序列
	3)长度为16的数据序列，只需经过4次合并，也就说，对于长度为n的数据序列，只需经过log@2 n次合并
	4)对于归并排序而言，其算法关键就在于合并，那么，如何将两个有序的数据序列合并成一个新的有序序列?合并算法的具体步骤如下
		(1)定义变量i,i从0开始，依次等于A序列中每个元素的索引
		(2)定义变量j,j从0开始，依次等于B序列中每个元素的索引
		(3)拿A序列中i索引处的元素和B序列中j索引处的元素进行比较，将较小的复制到一个临时数组中
		(4)如果i索引处的元素小，则i++,如果j索引处的的元素小，则j++
		不断地重复上面四个步骤，即可将A、B两个序列中的数据元素复制到临时数组中，直到其中一个数组中的所有元素都被复制到临时数组中，最后
		将另一个数组中多出来的元素全部复制到临时数组中，合并即完成，再将临时数组中的数据复制回去即可
	5)MergeSort
10.桶式排序
	1)桶式排序不再是一种基于比较的排序方法，它是一种非常巧妙的排序方式，但这种排序方式需要待排序序列满足如下特征
		(1)待排序序列的所有值处于一个可枚举范围内
		(2)待排序序列所在的这个可枚举范围不应该太大，否则排序开销太大
		下面介绍桶式排序的详细过程，如以下待排序列为例
		5,4,2,4,1
		这个待排序列处于0,1,2,3,4,5这个可枚举范围内，而且这个范围很小，正是桶式排序大派用场之时
		具体步骤如下
			a.对这个可枚举范围构建一个buckets数组，用于记录落入每个桶中的元素的个数，
			b.按如下公式对buckets数组的元素进行重新计算
			buckets[i]=buckets[i]+buckets[i-1](其中1<=i<=buckets.length)
	2)桶式排序的巧妙之处
		重新计算后的buckets数组元素保存了"落入"当前桶和"落入"前面桶中元素的总数目，而且定义的桶本身就是从小到大排列的，也就是说
		"落入"前面桶中的元素肯定小于"落入"当前桶中的元素，综合上面两点，得到了一个结论:每个buckets数组元素的值小于、等于"落入"当前桶中的元素的个数
		也就是说，"落入"当前桶中的元素在有序序列中应该排在buckets数组元素值所确定的位置
	3)上面理论还有点抽象，以待排序列中最后一个元素1为例，找到新buckets数组中元素1对应的桶的值，该值为1，这表明元素1就应该排在第1位，
		再以待排序序列中倒数第2个元素4为例，找到新buckets数组中元素4对应桶的值，该值为4，这表明元素4就应该排在第4位，依次类推
	4)BucketSort   
	5)桶式排序是一种非常优秀的排序算法，时间效率极高，它只需经过两轮遍历:第1轮遍历待排数据，统计每个待排数据"落入"各桶中的个数:
		第2论遍历用于重新计算每个buckets数组元素的值，两轮遍历后就可得到每个待排数据在有序序列中的位置，然后将各个数据项依次放入指定位置即可
	6)桶式排序空间开销较大，它需要两个数组:第1个buckets数组用于记录"落入"各桶中元素的个数，进而保存各元素在有序序列中的位置:
		第2个数组用于缓存待排数据，桶式排序是稳定的
11.基数排序
	1)基数排序已经不再是一种常规的排序方法，它更多地像是一种排序方法的应用，
		基数排序必须依赖于另外的排序方法，基数排序的总体思路就是将待排序数据拆分成多个关键字进行排序
		基数排序的实质是多关键字排序
	2)多关键字排序的思路是将待排序数据里的排序关键字拆分成多个排序关键字:第1个子关键字、第2个子关键字、第3个子关键字..然后根据子关键字对待排序数据进行排序
	3)在进行多关键字排序时有两种解决方案
		(1)最高位优先法MSD
		(2)最低位优先法LSD
		例如，对如下数据序列进行排序
		192,221,13,23
		可以观察到它的每个数据至多只有3位，因此可以将每个数据拆分成3个关键字:百位(高位)、十位、个位(低位)
	4)如果按照习惯思维，会先比较百位、百位大的数据大:百位相同的再比较十位,十位大的数据大,最后再比较个位，人的习惯思维是最高位优先方式
	5)如果 按照人的思维方式，计算机实现起来有一些困难，当开始比较十位时，程序还需要判断它们的百位是否相同-这就人为地增加了难度
		计算机通常会选择最低位优先法，如下所示
		(1)第1轮先比较个位，对个位关键字排序后得到序列为:
		221，192，13，23
		(2)第2轮先比较十位，对十位关键字排序后得到序列为:
		13，23，221，192
		(3)第3论先比较百位，对百位关键字排序后得到序列为:
		13，23，192，221
	6)基数排序方法对任一子关键字排序时必须借助于另一种排序方法，而且这种排序方法必须是稳定的
	7)如果这种排序算法不稳定，比如上面排序过程中，经过第2轮十位排序后，13位于23之前
		在第3轮百位排序时，如果该排序算法是稳定的，那么13依然位于23之前
	  如果该算法不稳定，那么可能13跑到23之后，这将导致排序失败
	8)现在的问题是，对子关键字排序时，到底选择哪种排序方式更合适?答案是桶式。
	 	回顾桶式排序的两个要求
		(1)待排序列的所有值处于一个可枚举范围
		(2)待排序列所在的这个可枚举范围不应该太大
		对于多关键字拆分出来的子关键	字,它们一定位于0~9这个可枚举范围内，这个范围不大，因此用桶式排序效率非常高
	9)MultiKeyRedixSort
	10）上面的基数排序其实就是多轮桶式排序，程序从最低位的关键字到最高位的关键字依次对待排数据进行排序，最后即可得到有序序列
	
		